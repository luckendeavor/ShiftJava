[TOC]

### æ ‘é¢˜ç›®

#### æŠ€å·§

- **é€’å½’**è§£æ·±åº¦ç›¸å…³çš„é¢˜ï¼Œå¯ä»¥è®¾ç½®ä¸€ä¸ª**å…¨å±€çš„æœ€å¤§æ·±åº¦**ï¼Œç”¨äº**è®°å½•å·²ç»è®¿é—®åˆ°çš„æœ€å¤§æ·±çš„æ·±åº¦**ã€‚
- æŒæ¡äºŒå‰æ ‘çš„**è¿­ä»£å±‚åºéå†**ï¼Œå¾ˆå¤šé¢˜å¯ç”¨ï¼åªéœ€å°‘é‡ä¿®æ”¹å³å¯ã€‚ä¸€èˆ¬å±‚åºéå†çš„é€’å½’è§£æ³•çš„æ¨¡æ¿ä¹Ÿæ˜¯å·®ä¸å¤šçš„ã€‚
- æŒæ¡äºŒå‰æ ‘çš„åºåˆ—åŒ– ä¸ååºåˆ—åŒ–æ–¹æ³•ï¼Œå¯ç”¨ç”¨äº**å­æ ‘é—®é¢˜**çš„åˆ¤æ–­ã€‚
- **é€’å½’éå†**çš„æ—¶å€™ï¼Œå¦‚æœéœ€è¦**æ”¹å˜é¡ºåº**ï¼Œå¯ä»¥è€ƒè™‘**å…ˆé€’å½’å³æ ‘**ã€‚
- æ±‚æ·±åº¦çš„é¢˜ç›®å¯ä»¥ç”¨é€’å½’ï¼Œä¹Ÿå¯ä»¥ç”¨**å±‚åºéå†**è¿›è¡Œè¿­ä»£æ±‚è§£ã€‚
- **æš´åŠ›é€’å½’**ç±»ä¼¼äº**ååºéå†**ï¼Œä¹Ÿå°±æ˜¯é»˜è®¤èƒ½å¾—åˆ°å·¦å³å­æ ‘çš„ä¿¡æ¯å†æ„é€ è‡ªå·±çš„ä¿¡æ¯ï¼Œ**æ ‘å½¢ dp**ã€‚



### æ™®é€šéå†ç±»é¢˜ç›®

æ ‘çš„éå†æ–¹å¼æ€»ä½“åˆ†ä¸º**ä¸¤ç±»**ï¼š**æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰ã€å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰**ï¼š

- **å¸¸è§çš„ DFS** ï¼š **å…ˆåºéå†ã€ä¸­åºéå†ã€ååºéå†**ã€‚
- **å¸¸è§çš„ BFS** ï¼š **å±‚åºéå†ï¼ˆå³æŒ‰å±‚éå†ï¼‰**ã€‚

#### äºŒå‰æ ‘éå†

##### 1. é¢˜ç›®

å†™å‡ºäºŒå‰æ ‘çš„**å‰åºã€ä¸­åºã€ååº**éå†ã€‚

##### 2. é¢˜è§£

**é€’å½’æ–¹å¼**ä¼šè®¿é—®ä¸€ä¸ªç»“ç‚¹**ä¸‰æ¬¡**ï¼Œåœ¨**ç¬¬å‡ æ¬¡è¿›è¡Œæ•°æ®å¤„ç†**å°±æ˜¯ä¸åŒçš„é¡ºåºäº†ã€‚

###### (1) é€’å½’æ–¹å¼å‰åºéå†ã€ç®€å•ã€‘

```java
public void preOrderRecursive(TreeNode root) {
    if (root == null) return;
    // ç¬¬ä¸€æ¬¡åˆ°è¾¾ç»“ç‚¹æ—¶å¤„ç†æ•°æ®
    System.out.println(root.val + " ");
    preOrderRecursive(root.left);
    preOrderRecursive(root.right);
}
```

###### (2) é€’å½’æ–¹å¼ä¸­åºéå†ã€ç®€å•ã€‘

```java
public void midOrderRecursive(TreeNode root) {
    if (root == null) return;
    preOrderRecursive(root.left);
    // ç¬¬äºŒæ¬¡åˆ°è¾¾ç»“ç‚¹æ—¶å¤„ç†æ•°æ®
    System.out.println(root.val + " ");
    preOrderRecursive(root.right);
}
```

######  (3) é€’å½’æ–¹å¼ååºéå†ã€ç®€å•ã€‘

```java
public void postOrderRecursive(TreeNode root) {
    if (root == null) return;
    preOrderRecursive(root.left);
    preOrderRecursive(root.right);
    // ç¬¬ä¸‰æ¬¡åˆ°è¾¾ç»“ç‚¹æ—¶å¤„ç†æ•°æ®
    System.out.println(root.val + " ");
}
```

###### [(4) 144.è¿­ä»£æ–¹å¼å‰åºéå†ã€ä¸­ç­‰ã€‘](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

è¿­ä»£æ³•æœ¬è´¨ä¸Šæ˜¯åœ¨**æ¨¡æ‹Ÿé€’å½’**ï¼Œå› ä¸ºåœ¨é€’å½’çš„è¿‡ç¨‹ä¸­ä½¿ç”¨äº†ç³»ç»Ÿæ ˆï¼Œæ‰€ä»¥åœ¨è¿­ä»£çš„è§£æ³•ä¸­å¸¸ç”¨`Stack`æ¥æ¨¡æ‹Ÿç³»ç»Ÿæ ˆã€‚

ä½¿ç”¨**æ ˆ**ï¼Œå…ˆå°†**æ ¹èŠ‚ç‚¹å‹æ ˆ**ï¼Œåªè¦**æ ˆä¸ä¸ºç©ºåˆ™ä¸€ç›´å¼¹å‡º**ï¼Œå¼¹å‡ºä¸€ä¸ªå¤„ç†æ•°æ®ï¼Œç„¶å**å…ˆå‹å…¥å³å­ç»“ç‚¹ï¼Œå†å‹å…¥å·¦å­ç»“ç‚¹**ï¼ˆç”±äºæ˜¯åˆ©ç”¨æ ˆï¼Œæ‰€ä»¥å‹å…¥é¡ºåºç›¸åæ˜¯**==å…ˆå³åå·¦==**ï¼‰ã€‚

- å…ˆå°†**æ ¹èŠ‚ç‚¹**å…¥**æ ˆ**ã€‚
- ä»æ ˆ**å¼¹å‡º**ä¸€ä¸ªç»“ç‚¹ï¼Œå¼¹å‡ºå**å¤„ç†æ•°æ®**ã€‚
- å¦‚æœæ ¹èŠ‚ç‚¹å­˜åœ¨**å³**å­©å­ï¼Œåˆ™å°†**å³å­©å­**å…¥æ ˆã€‚
- å¦‚æœæ ¹èŠ‚ç‚¹å­˜åœ¨**å·¦**å­©å­ï¼Œåˆ™å°†**å·¦å­©å­**å…¥æ ˆï¼ˆæ³¨æ„ï¼š**ä¸€å®šæ˜¯å³å­©å­å…ˆå…¥æ ˆï¼Œç„¶åå·¦å­©å­å…¥æ ˆ**ï¼‰ã€‚
- é‡å¤ 2 - 4 ç›´åˆ°**æ ˆä¸ºç©º**ã€‚

```java
public List<Integer> preorderTraversal(TreeNode root) {
    if(root == null) return new ArrayList<>();
    List<Integer> resList = new ArrayList<>();
    // å‡†å¤‡ä¸€ä¸ªæ ˆå¹¶æŠŠæ ¹èŠ‚ç‚¹å‹æ ˆ
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    // ä¸æ–­ä»æ ˆä¸­å¼¹å‡ºå…ƒç´ å¼¹å‡ºæ—¶å¤„ç†æ•°æ®ï¼Œå¹¶å…ˆå°†å³å­©å­å‹æ ˆå†å°†å·¦å­©å­å‹æ ˆ
    while(!stack.isEmpty()) {
        TreeNode node = stack.pop();
        resList.add(node.val);
        // å…ˆå‹å…¥å³ç»“ç‚¹ï¼Œå†å‹å…¥å·¦ç»“ç‚¹
        if(node.right != null) stack.push(node.right);
        if(node.left != null) stack.push(node.left);
    }
    return resList;
}
```

###### [(5) 94.è¿­ä»£æ–¹å¼ä¸­åºéå†ã€ä¸­ç­‰ã€‘](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

**é€’å½’çš„è°ƒç”¨è¿‡ç¨‹æ˜¯ä¸æ–­å¾€å·¦è¾¹èµ°ï¼Œå½“å·¦è¾¹èµ°ä¸ä¸‹å»äº†ï¼Œå°±æ‰“å°èŠ‚ç‚¹ï¼Œå¹¶è½¬å‘å³è¾¹ï¼Œç„¶åå³è¾¹ç»§ç»­è¿™ä¸ªè¿‡ç¨‹ã€‚**åœ¨è¿­ä»£å®ç°æ—¶ï¼Œå°±å¯ä»¥ç”¨æ ˆæ¥æ¨¡æ‹Ÿè¿™ä¸ªè°ƒç”¨è¿‡ç¨‹ã€‚ä¹Ÿæ˜¯åˆ©ç”¨**æ ˆ**çš„æ–¹å¼è¿›è¡Œã€‚ç®—æ³•è¿‡ç¨‹å¦‚ä¸‹ï¼š

- å…ˆå°†**æ ¹èŠ‚ç‚¹**å…¥æ ˆã€‚
- å°†å½“å‰èŠ‚ç‚¹çš„**æ‰€æœ‰å·¦å­©å­**å…¥æ ˆï¼Œç›´åˆ°**å·¦å­©å­ä¸ºç©º**ã€‚
- è®¿é—®**æ ˆé¡¶**å…ƒç´ ï¼Œå¦‚æœæ ˆé¡¶å…ƒç´ **å­˜åœ¨å³å­©å­**ï¼Œåˆ™å˜æ¢åˆ°**å³å­èŠ‚ç‚¹**ç»§ç»­ç¬¬ 2 æ­¥ã€‚
- é‡å¤ç¬¬ 2ã€3 æ­¥ï¼Œç›´åˆ°**æ ˆä¸ºç©º**å¹¶ä¸”æ‰€æœ‰çš„èŠ‚ç‚¹éƒ½è¢«è®¿é—®ã€‚

<img src="assets/47fff35dd3fd640ba60349c78b85242ae8f4b850f06a282cd7e92c91e6eff406-1.gif" alt="ä¸­åºéå†è¿­ä»£åŠ¨å›¾" style="zoom:70%;" />

æ³¨æ„è¿™é‡Œ**ä¸ç”¨æŠŠæ ¹ç»“ç‚¹å‹å…¥æ ˆ**ä¸­ã€‚

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    // æ¡ä»¶æ˜¯æ ˆä¸ä¸ºç©ºä¸”rootä¸ä¸ºnull
    while (!stack.isEmpty() || root != null) {
        // å°†å…¨éƒ¨å·¦å­ç»“ç‚¹å‹æ ˆ,è¿™æ˜¯æ¨¡æ‹Ÿé€’å½’çš„è°ƒç”¨
        if (root != null) {
            stack.push(root);
            root = root.left;
            // å½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼Œè¯´æ˜å·¦è¾¹èµ°åˆ°å¤´äº†ï¼Œä»æ ˆä¸­å¼¹å‡ºèŠ‚ç‚¹å¹¶ä¿å­˜
        } else {
            TreeNode temp = stack.pop();
            res.add(temp.val);
            // ç„¶åè½¬å‘å³è¾¹èŠ‚ç‚¹ï¼Œç»§ç»­ä¸Šé¢æ•´ä¸ªè¿‡ç¨‹
            root = temp.right;
        }
    }
    return res;
}
```

###### [(6) 145.è¿­ä»£æ–¹å¼ååºéå†ã€å›°éš¾ã€‘](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

ä½¿ç”¨**ä¸¤ä¸ªæ ˆ** s1 å’Œ s2ã€‚**å‰åºéå†**çš„è¿‡ç¨‹ æ˜¯ **ä¸­å·¦å³**ã€‚å°†å…¶è½¬åŒ–æˆ **ä¸­å³å·¦**ã€‚ä¹Ÿå°±æ˜¯å‹æ ˆçš„è¿‡ç¨‹ä¸­**ä¼˜å…ˆå‹å…¥å·¦å­æ ‘ï¼Œåœ¨å‹å…¥å³å­æ ‘**ã€‚ç„¶åå°†è¿™ä¸ªç»“æœ**è¿”å›æ¥**ï¼Œè¿™é‡Œæ˜¯åˆ©ç”¨æ ˆçš„å…ˆè¿›åå‡º**å€’åºæ‰“å°**ï¼Œå³æ˜¯ååºéå†ã€‚

1. å°†**æ ¹èŠ‚ç‚¹**å‹å…¥ s1 ä¸­ã€‚
2. ä» s1 ä¸­**å¼¹å‡º**å…ƒç´ ï¼Œå¹¶ä¾æ¬¡å°†å…¶**==å·¦å­©å­å’Œå³å­©å­å‹å…¥ s1==** ä¸­ã€‚æ­¤è¿‡ç¨‹ä¸­**==æ¯ä» s1 å¼¹å‡ºä¸€ä¸ªå…ƒç´ éƒ½å°†å…¶å‹å…¥åˆ°æ ˆ s2 ä¸­==**ã€‚ç›´åˆ° **==s1 ä¸ºç©º==**ä¸ºæ­¢ã€‚
3. ä» **s2 ä¸­ä¾æ¬¡å¼¹å‡ºå…ƒç´ **å¤„ç†å³æ˜¯**ååºéå†**ã€‚

```java
public List<Integer> postorderTraversal(TreeNode root) {

    if (root == null) return new ArrayList<>();
    List<Integer> resList = new ArrayList<>();


    // å‡†å¤‡ä¸¤ä¸ªæ ˆ
    Stack<TreeNode> s1 = new Stack<>();
    Stack<TreeNode> s2 = new Stack<>();
    // æ ¹èŠ‚ç‚¹å‹å…¥æ ˆ1
    s1.push(root);
    // é€€å‡ºæ¡ä»¶ä¸ºæ ˆ1ä¸ºç©º
    while (!s1.isEmpty()) {
        // æ ˆ1æ¯å¼¹å‡ºä¸€ä¸ªå…ƒç´ å°±æ”¾å…¥æ ˆ2
        root = s1.pop();
        s2.push(root);

        // å†å°†å½“å‰å¼¹å‡ºå…ƒç´ çš„å·¦å³å­èŠ‚ç‚¹åˆ†åˆ«å…¥æ ˆ,ä¸€å®šæ˜¯å…ˆå·¦å†å³
        if (root.left != null) s1.push(root.left);
        if (root.right != null) s1.push(root.right);
    }
    // å½“æ ˆ1ä¸ºç©ºæ—¶ï¼Œä¾æ¬¡å¼¹å‡ºæ ˆ2å°±æ˜¯ååºéå†é¡ºåº
    while (!s2.isEmpty()) {
        resList.add(s2.pop().val);
    }
    return resList;
}
```

###### (7) äºŒå‰æ ‘çš„Morriséå†ã€å›°éš¾ã€‘

å‚è€ƒï¼šhttps://www.jianshu.com/p/484f587c967c

å¯ä»¥æ ¹æ® Morris éå†**åŠ å·¥å‡ºäºŒå‰æ ‘çš„å‰ä¸­ååºéå†**ã€‚ç©ºé—´å¤æ‚åº¦ **O(1)**ã€‚



#### 590.Nå‰æ ‘çš„ååºéå†ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

ä½¿ç”¨**ååºéå†**æ–¹å¼éå†ä¸€é¢— N å‰æ ‘ã€‚ååºéå†é¡ºåºä¸ºï¼š[5, 6, 3, 2, 4, 1]ã€‚

<img src="assets/image-20200705143003163.png" alt="image-20200705143003163" style="zoom:40%;" />

å¤šå‰æ ‘ç»“ç‚¹ç±» Node å¦‚ä¸‹ã€‚

```java
public class Node {
	public int val;
	public List<Node> children;
	public Node() {}
	public Node(int val) {
		this.val = val;
	}
	public Node(int val, List<Node> children) {
		this.val = val;
		this.children = children;
	}
}
```

##### 2. é¢˜è§£

###### (1) é€’å½’DFS

ç›´æ¥ä½¿ç”¨**é€’å½’**çš„æ–¹å¼è¿›è¡Œéå†ã€‚æ¯”è¾ƒç®€å•ï¼Œå‚è€ƒæ™®é€šçš„é€’å½’ååºéå†ã€‚

```java
private List<Integer> resList;

public List<Integer> postorder(Node root) {
    resList = new LinkedList<>();
    // æ·±åº¦ä¼˜å…ˆéå†
    dfs(root);
    return resList;
}

private void dfs(Node root) {
    // Base case
    if(root == null) return;
    // æ•´ä½“ååºéå†çš„æ¶æ„ï¼Œå…ˆéå†å…¨éƒ¨å­ç»“ç‚¹æœ€åå†å¤„ç†æ•°æ®
    for(Node child : root.children) {
        dfs(child);
    }
    resList.add(root.val);
}
```

###### (2) è¿­ä»£æ³•

å¯ä»¥ä½¿ç”¨å’Œ **Nå‰æ ‘çš„å‰åºéå†** ç›¸åŒçš„æ–¹æ³•ï¼Œä½¿ç”¨ä¸€ä¸ª**æ ˆ**æ¥å¾—åˆ°**ååºéå†**ã€‚é¦–å…ˆæŠŠ**æ ¹èŠ‚ç‚¹å…¥æ ˆ**ã€‚å½“æ¯æ¬¡ä»**æ ˆé¡¶**å–å‡ºä¸€ä¸ªèŠ‚ç‚¹ u æ—¶ï¼Œå°±æŠŠ u çš„**æ‰€æœ‰å­èŠ‚ç‚¹é¡ºåºå‹å…¥æ ˆ**ä¸­ã€‚ä¾‹å¦‚ u çš„å­èŠ‚ç‚¹ä»å·¦åˆ°å³ä¸º **v1, v2, v3**ï¼Œé‚£ä¹ˆæ¨å…¥æ ˆçš„é¡ºåºåº”å½“ä¸º v1, v2, v3ï¼Œè¿™æ ·å°±ä¿è¯äº†**ä¸‹ä¸€ä¸ªéå†åˆ°çš„èŠ‚ç‚¹**ï¼ˆå³ u çš„ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹ v3ï¼‰å‡ºç°åœ¨**æ ˆé¡¶**çš„ä½ç½®ã€‚åœ¨éå†ç»“æŸä¹‹åï¼Œæˆ‘ä»¬æŠŠéå†ç»“æœ**åè½¬**ï¼Œå°±å¯ä»¥å¾—åˆ°ååºéå†ã€‚

```java
public List<Integer> postorder2(Node root) {
    // Base case
    if (root == null) return new ArrayList<>();
    // ä½¿ç”¨ä¸€ä¸ªæ ˆå­˜å‚¨ç»“ç‚¹
    Stack<Node> stack = new Stack<>();
    // å­˜æ”¾ç»“æœ
    LinkedList<Integer> resList = new LinkedList<>();
    // æ ¹èŠ‚ç‚¹å…¥æ ˆ
    stack.add(root);
    // ç»“æŸæ¡ä»¶æ˜¯æ ˆä¸ºç©º
    while (!stack.isEmpty()) {
        // æ ˆä¸­å¼¹å‡ºä¸€ä¸ªç»“ç‚¹
        Node node = stack.pop();
        // å°†å¼¹å‡ºèŠ‚ç‚¹çš„å­ç»“ç‚¹å…ƒç´ åŠ å…¥ç»“æœ
        resList.addFirst(node.val);
        // é¡ºåºå‹å…¥å…¶ä»–å­èŠ‚ç‚¹
        for (Node item : node.children) {
            if (item != null) {
                stack.add(item);
            }
        }
    }
    return resList;
}
```



### å±‚åºéå†ç±»é¢˜ç›®

æ ‘çš„**å±‚åºéå†**çš„å¥—è·¯åŠå…¶æ·±åšï¼ŒæŒæ¡**ä½¿ç”¨é˜Ÿåˆ—çš„æ¨¡æ¿**å°±è¡Œäº†ã€‚

#### 102.äºŒå‰æ ‘çš„å±‚åºéå† Iã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ **å±‚åºéå†** å¾—åˆ°çš„èŠ‚ç‚¹å€¼ï¼Œå³**é€å±‚åœ°**ï¼Œ**ä»å·¦åˆ°å³**è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ã€‚

ç¤ºä¾‹ï¼šäºŒå‰æ ‘ï¼š[3, 9, 20, null, null, 15, 7]

```java
    3
   / \
  9  20
    /  \
   15   7
```

è¿”å›å…¶å±‚æ¬¡éå†ç»“æœï¼š

```java
[
  [3],
  [9,20],
  [15,7]
]
```

##### 2. é¢˜è§£

###### (1) è¿­ä»£æ³•BFS

å¯¹äºŒå‰æ ‘çš„å±‚åºéå†å°±æ˜¯**ä½¿ç”¨ BFS éå†**ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨**é˜Ÿåˆ—**è¿›è¡Œè¾…åŠ©ã€‚ä¸‹é¢çš„æ¨¡æ¿æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œè®°ä½å¯ä»¥è§£å¾ˆå¤šé¢˜ã€‚

- ==**æ ¹èŠ‚ç‚¹å…¥é˜Ÿã€‚**==
- ==**å¾ªç¯ç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºï¼Œæ¯æ¬¡å‡ºé˜Ÿä¸€ä¸ªç»“ç‚¹ï¼Œå¹¶å°†å…¶å·¦å³å­èŠ‚ç‚¹å…¥é˜Ÿã€‚**==
- ==**ä¸ºäº†æ§åˆ¶æŒ‰å±‚è¿›è¡Œæ‰“å°ï¼Œéœ€è¦æœ‰ä¸ªå¾ªç¯è®°å½•ä¸€ä¸‹è¿™ä¸€å±‚çš„ç»“ç‚¹ä¸ªæ•°ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸€ä¸ª for å¾ªç¯æ¥éå†è¿™ä¸€å±‚ã€‚**==
- ==**å½“ä¸€å±‚çš„å…ƒç´ å¤„ç†å®Œçš„æ—¶å€™ï¼Œä¸‹ä¸€å±‚çš„ç»“ç‚¹åˆå·²ç»å…¨éƒ¨å…¥é˜Ÿï¼ŒæŒç»­å¾ªç¯å³å¯ã€‚**==

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    // Base case
    if(root == null) return new ArrayList<>();
    // ä½¿ç”¨è¾…åŠ©é˜Ÿåˆ—å¹¶å°†æ ¹èŠ‚ç‚¹å…¥é˜Ÿåˆ—
    Queue<TreeNode> queue = new LinkedList<>() ;
    queue.add(root);
    List<List<Integer>> resList = new ArrayList<>();
    // é˜Ÿåˆ—ä¸ºç©ºæ—¶é€€å‡ºå¾ªç¯
    while(queue.size() != 0) {
        // è·å–å½“å‰é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ªæ•°ï¼Œä¹Ÿå°±æ˜¯å½“å‰è¿™ä¸€å±‚æœ‰å¤šå°‘ä¸ªç»“ç‚¹ï¼Œè¿™æ˜¯ä¸ºäº†æ§åˆ¶è®¿é—®åˆ°äº†æŸä¸€å±‚
        int size = queue.size();
        List<Integer> levelList = new ArrayList<>();
        // å°†å½“å‰å±‚çš„å…ƒç´ ä¾æ¬¡å‡ºé˜Ÿåˆ—å¹¶å¤„ç†æ•°æ®ï¼Œæ¯å¼¹å‡ºä¸€ä¸ªç»“ç‚¹å¹¶å†æ¬¡å°†å…¶å·¦å³å­èŠ‚ç‚¹å…¥é˜Ÿåˆ—
        for(int i = 0; i < size; i++) {
            // å‡ºé˜Ÿåˆ—å¹¶å¤„ç†æ•°æ®
            TreeNode temp = queue.poll();
            levelList.add(temp.val);
            // å°†å‡ºé˜Ÿç»“ç‚¹çš„å·¦å³å­èŠ‚ç‚¹å…¥é˜Ÿ
            if(temp.left != null) queue.add(temp.left);
            if(temp.right != null) queue.add(temp.right);
        }
        // è¿™ä¸€å±‚å¼¹å‡ºçš„å…ƒç´ å¤„ç†å®Œæ¯•
        resList.add(levelList);
        // æ­¤æ—¶ä¸‹ä¸€å±‚çš„å…¨éƒ¨èŠ‚ç‚¹å·²ç»åˆ°é˜Ÿåˆ—ä¸­ï¼Œå†æ¬¡å¾ªç¯å³å¯
    }
    return resList;
}
```

###### (2) é€’å½’æ³•DFS

é¦–å…ˆç¡®è®¤æ ‘**éç©º**ï¼Œç„¶åè°ƒç”¨**é€’å½’å‡½æ•°** process(node, level)ï¼Œå‚æ•°æ˜¯**å½“å‰èŠ‚ç‚¹å’ŒèŠ‚ç‚¹çš„å±‚æ¬¡**ã€‚ç¨‹åºè¿‡ç¨‹å¦‚ä¸‹ï¼š

- è¾“å‡ºåˆ—è¡¨ç§°ä¸º resListï¼Œå½“å‰**æœ€é«˜å±‚æ•°**å°±æ˜¯åˆ—è¡¨çš„**é•¿åº¦ size()**ã€‚æ¯”è¾ƒè®¿é—®èŠ‚ç‚¹**æ‰€åœ¨çš„å±‚æ¬¡ level** å’Œ**å½“å‰æœ€é«˜å±‚**æ¬¡ size çš„å¤§å°ï¼Œå¦‚æœå‰è€…**æ›´å¤§å°±è¯´æ˜è®¿é—®åˆ°äº†æ–°çš„ level åˆ™å‘ resList æ·»åŠ ä¸€ä¸ªç©ºåˆ—è¡¨**ã€‚
- å°†å½“å‰èŠ‚ç‚¹æ’å…¥åˆ°**å¯¹åº”å±‚çš„åˆ—è¡¨** **resList[level]** ä¸­ã€‚
- é€’å½’**éç©ºçš„å­©å­èŠ‚ç‚¹**ï¼šprocess(node.left / node.rightï¼Œlevel + 1)ã€‚

```java
public List<List<Integer>> levelOrder2(TreeNode root) {
    if (root == null) return resList;
    // ä»æ ¹ç»“ç‚¹å¼€å§‹é€’å½’,æ ¹ç»“ç‚¹æ˜¯ç¬¬0å±‚
    dfs(root, 0);
    return resList;
}

List<List<Integer>> resList = new ArrayList<>();

// è¾…åŠ©æ–¹æ³•:æ•´ä½“æ˜¯å…ˆåºéå†çš„æ¨¡æ¿
public void dfs(TreeNode node, int level) {
    // è¯´æ˜é‡åˆ°äº†æ–°çš„ä¸€å±‚åˆ™æ–°å»ºä¸€ä¸ªåˆ—è¡¨,å¹¶æ·»åŠ ä¸€å±‚æ–°çš„åˆ°ç»“æœä¸­
    if (resList.size() == level) {
        resList.add(new ArrayList<>());
    }
    // æ ¹æ®å±‚æ•°è·å–å¯¹åº”çš„åˆ—è¡¨å¹¶å°†å½“å‰èŠ‚ç‚¹çš„å€¼åŠ å…¥åˆ°listä¸­ï¼ˆå…ˆåºéå†ï¼‰
    resList.get(level).add(node.val);

    // é€’å½’è¿›è¡Œ
    if (node.left != null) dfs(node.left, level + 1);
    if (node.right != null) dfs(node.right, level + 1);
}
```

#### 107.äºŒå‰æ ‘çš„å±‚æ¬¡éå† IIã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii)

åŒºåˆ«ä¸Šä¸€ä¸ªé¢˜ç›®ã€‚ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼**è‡ªåº•å‘ä¸Šçš„å±‚æ¬¡éå†**ã€‚ ï¼ˆå³æŒ‰ä»å¶å­èŠ‚ç‚¹æ‰€åœ¨å±‚åˆ°**æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å±‚**ï¼Œé€å±‚ä»å·¦å‘å³éå†ï¼‰ã€‚

ä¾‹å¦‚ï¼šç»™å®šäºŒå‰æ ‘ [3, 9, 20, null, null, 15, 7]

```java
	3
   / \
  9  20
    /  \
   15   7
```

è¿”å›å…¶è‡ªåº•å‘ä¸Šçš„å±‚æ¬¡éå†ä¸ºï¼š

```java
[
  [15,7],
  [9,20],
  [3]
]
```

##### 2. é¢˜è§£

æ€è·¯ç±»ä¼¼å‰é¢çš„æ™®é€šå±‚åºéå†ï¼Œä½†æ˜¯æ˜¯**åè¿‡æ¥**çš„ï¼Œå…¶å®å¾ˆå®¹æ˜“æƒ³åˆ°åªéœ€è¦æŠŠä¸Šè¿°é¢˜ç›®çš„**è§£é€†åº**å³å¯ã€‚å‚è€ƒä¸Šè¿°çš„ **BFS** è§£æ³•ï¼Œåªéœ€åœ¨**æœ€åè°ƒç”¨**ã€‚

```java
Collections.reverse(resList);
```

å°†ç»“æœ**é€†åº**å³å¯ã€‚

#### 429.Nå‰æ ‘çš„å±‚åºéå†ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

ç»™å®šä¸€ä¸ª **N å‰æ ‘**ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„**å±‚åºéå†**ã€‚ (å³ä»å·¦åˆ°å³ï¼Œé€å±‚éå†)ã€‚ä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ª `3å‰æ ‘` :

<img src="assets/image-20200425092141499.png" alt="image-20200425092141499" style="zoom:43%;" />

è¿”å›å…¶å±‚åºéå†ï¼š

```java
[
   [1],
   [3,2,4],
   [5,6]
]
```

##### 2. é¢˜è§£

###### (1) è¿­ä»£æ³•BFS

å‚è€ƒæ™®é€šçš„å±‚åºéå†æ–¹æ³•ï¼Œä¹Ÿæ˜¯ä½¿ç”¨ä¸€ä¸ª**é˜Ÿåˆ—**ï¼Œæ¯å‡ºä¸€ä¸ªé˜Ÿåˆ—å…ƒç´ å°±å°†**å…¶å…¨éƒ¨å­å…ƒç´ æ”¾å…¥é˜Ÿåˆ—**ä¸­ã€‚

è¯¦ç»†å›¾ç¤ºï¼šhttps://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/

```java
public List<List<Integer>> levelOrder(Node root) {
    // Base case
    if(root == null) return new ArrayList<>();
    // ä½¿ç”¨è¾…åŠ©é˜Ÿåˆ—å¹¶å°†æ ¹èŠ‚ç‚¹å…¥é˜Ÿåˆ—
    Queue<Node> queue = new LinkedList<>();
    queue.offer(root);
    List<List<Integer>> resList = new ArrayList<>();
    // é˜Ÿåˆ—ä¸ºç©ºé€€å‡ºå¾ªç¯
    while(!queue.isEmpty()) {
        // è®°å½•å½“å‰å±‚çš„ç»“ç‚¹ä¸ªæ•°
        int size = queue.size();
        // è®°å½•å½“å‰å±‚çš„ç»“æœ
        List<Integer> levelList = new ArrayList<>();
        // ä¾æ¬¡å¼¹å‡ºå½“å‰å±‚ç»“ç‚¹å¹¶å°†å…¶å­èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­åŒæ—¶å¤„ç†æ•°æ®
        for(int i = 0; i < size; i++) {
            // å¼¹å‡ºèŠ‚ç‚¹å¹¶å¤„ç†å…ƒç´ 
            Node temp = queue.poll();
            levelList.add(temp.val);
            // å°†è¯¥å¼¹å‡ºèŠ‚ç‚¹çš„å…¨éƒ¨å­ç»“ç‚¹ä¾æ¬¡åŠ å…¥é˜Ÿåˆ—ä¸­
            for(Node node : temp.children) {
                queue.offer(node);
            }
        }
        resList.add(levelList);
    }
    return resList;
}
```

###### (2) é€’å½’DFS

å¯ä»¥ä½¿ç”¨**é€’å½’**æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œé€šå¸¸**ä¸èƒ½ä½¿ç”¨é€’å½’è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢**ã€‚è¿™æ˜¯å› ä¸ºå¹¿åº¦ä¼˜å…ˆæœç´¢åŸºäºé˜Ÿåˆ—ï¼Œè€Œé€’å½’è¿è¡Œæ—¶ä½¿ç”¨**å †æ ˆ**ï¼Œé€‚åˆ**æ·±åº¦**ä¼˜å…ˆæœç´¢ã€‚ä½†å¯ä»¥**ä»¥ä¸åŒçš„é¡ºåºæ·»åŠ åˆ°æœ€ç»ˆåˆ—è¡¨**ä¸­ï¼Œåªè¦**çŸ¥é“èŠ‚ç‚¹åœ¨å“ªä¸€å±‚å¹¶ç¡®ä¿åœ¨é‚£ä¸€å±‚çš„åˆ—è¡¨é¡ºåºæ­£ç¡®**å°±å¯ä»¥äº†ã€‚

è¿™é‡Œé€’å½’çš„æ–¹å¼ä¹Ÿæ˜¯ç±»ä¼¼ä¸Šé¢çš„äºŒå‰æ ‘çš„å±‚åºéå†æ–¹å¼ã€‚

```java
// ç»“æœåˆ—è¡¨
private List<List<Integer>> resList = new ArrayList<>();

public List<List<Integer>> levelOrder2(Node root) {
    // ä»ç¬¬0å±‚å¼€å§‹
    if (root != null) traverseNode(root, 0);
    return resList;
}

// é€’å½’æ–¹æ³• ä¼ å…¥å±‚æ•°
private void traverseNode(Node node, int level) {
    // è¯´æ˜å½“å‰å±‚å¤§äºç»“æœListçš„sizeï¼Œéœ€è¦æ–°å»ºä¸€ä¸ªlistæ¥å­˜å‚¨å½“å‰å±‚çš„å…ƒç´ 
    if (resList.size() <= level) resList.add(new ArrayList<>());
    // è·å–å½“å‰levelæ‰€å¯¹åº”çš„listï¼Œå¹¶å¤„ç†å½“å‰èŠ‚ç‚¹çš„æ•°æ®åŠ å…¥åˆ°åé¢
    resList.get(level).add(node.val);
    // é€’å½’å…¨éƒ¨å­èŠ‚ç‚¹ï¼Œlevel + 1
    for (Node child : node.children) {
        traverseNode(child, level + 1);
    }
}
```

#### 637.äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree)

ç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘, è¿”å›ä¸€ä¸ªç”±**æ¯å±‚**èŠ‚ç‚¹**å¹³å‡å€¼**ç»„æˆçš„æ•°ç»„ã€‚

```java
    3
   / \
  9  20
    /  \
   15   7
```

è¾“å‡º: [3, 14.5, 11]ã€‚è§£é‡Šï¼šç¬¬ 0 å±‚çš„å¹³å‡å€¼æ˜¯ 3,  ç¬¬ 1 å±‚æ˜¯ 14.5, ç¬¬ 2 å±‚æ˜¯ 11ã€‚å› æ­¤è¿”å› [3, 14.5, 11]ã€‚

##### 2. é¢˜è§£

###### (1) è¿­ä»£æ³•BFS

å‚è€ƒ**å±‚åºéå†**äºŒå‰æ ‘çš„ä»£ç ï¼Œæ±‚**æ¯ä¸€å±‚çš„å¹³å‡å€¼**å³å¯ã€‚åœ¨åŸæ¥çš„ä»£ç ä¸Šå°æ”¹å³å¯ã€‚

```java
public List<Double> averageOfLevels(TreeNode root) {
    // Base case
    if(root == null) return new ArrayList<>();
    // æ ¹èŠ‚ç‚¹å…¥é˜Ÿåˆ—
    Queue<TreeNode> queue = new LinkedList<>() ;
    queue.add(root);
    List<Double> resList = new ArrayList<>();
    // é˜Ÿåˆ—ä¸ºç©ºæ—¶æ¨é€€å‡ºå¾ªç¯
    while(queue.size() != 0) {
        // è·å–å½“å‰é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ªæ•°ï¼Œä¹Ÿå°±æ˜¯å½“å‰è¿™ä¸€å±‚æœ‰å¤šå°‘ä¸ªç»“ç‚¹
        int size = queue.size();
        // ä¿å­˜è¿™ä¸€å±‚çš„èŠ‚ç‚¹æ•°å€¼çš„å’Œ
        double sum = 0;
        // å°†å½“å‰å±‚çš„å…ƒç´ ä¾æ¬¡å‡ºé˜Ÿåˆ—å¹¶å¤„ç†æ•°æ®ï¼Œæ¯å¼¹å‡ºä¸€ä¸ªç»“ç‚¹å¹¶å†æ¬¡å°†å…¶å·¦å³å­èŠ‚ç‚¹å…¥é˜Ÿåˆ—
        for(int i = 0; i < size; i++) {
            // å‡ºé˜Ÿåˆ—å¹¶å¤„ç†æ•°æ®
            TreeNode temp = queue.poll();
            // è½¬æ¢æˆdoubleç±»å‹
            sum = sum + (double)temp.val;
            // å°†å‡ºé˜Ÿç»“ç‚¹çš„å·¦å³å­èŠ‚ç‚¹å…¥é˜Ÿ
            if(temp.left != null) queue.add(temp.left);
            if(temp.right != null) queue.add(temp.right);
        }
        // è¿™ä¸€å±‚å¼¹å‡ºçš„å…ƒç´ å¤„ç†å®Œæ¯•
        resList.add(sum / size);
    }
    return resList;
}
```

###### (2) é€’å½’DFS

å¯ä»¥ä½¿ç”¨**æ·±åº¦ä¼˜å…ˆæœç´¢**éå†æ•´é¢—äºŒå‰æ ‘ã€‚ä½¿ç”¨**ä¸¤ä¸ªæ•°ç»„ sum** å­˜æ”¾æ ‘ä¸­**æ¯ä¸€å±‚çš„èŠ‚ç‚¹æ•°å€¼ä¹‹å’Œ**ï¼Œä»¥åŠ **count** å­˜æ”¾æ ‘ä¸­æ¯ä¸€å±‚çš„**èŠ‚ç‚¹æ•°é‡ä¹‹å’Œ**ã€‚åœ¨éå†æ—¶éœ€è¦**é¢å¤–è®°å½•å½“å‰èŠ‚ç‚¹æ‰€åœ¨çš„é«˜åº¦**ï¼Œå¹¶æ ¹æ®é«˜åº¦ h **æ›´æ–°æ•°ç»„å…ƒç´  sum[h]** å’Œ count[h]ã€‚åœ¨éå†ç»“æŸä¹‹åï¼Œ**res = sum / cnt** å³ä¸ºç­”æ¡ˆã€‚

```java
public List <Double> averageOfLevels2(TreeNode root) {
    List<Double> resList = new ArrayList<>();
    // è®°å½•æ¯å±‚çš„å…ƒç´ ä¸ªæ•°æ•°ç»„
    List <Integer> numberList = new ArrayList<>();
    // è®°å½•æ¯å±‚å…ƒç´ å’Œæ•°ç»„
    List <Double> sumList = new ArrayList<>();
    // é€’å½’æ±‚ä¸Šè¿°çš„ä¸¤ä¸ªæ•°ç»„çš„å€¼
    dfs(root, 0, sumList, numberList);
    // æ±‚å¹³å‡å€¼ï¼ˆå› ä¸ºä¸¤ä¸ªæ•°ç»„æ˜¯å¯¹åº”çš„ï¼‰
    for (int i = 0; i < resList.size(); i++)
        resList.set(i, sumList.get(i) / numberList.get(i));
    return sumList;
}

// è¿›è¡ŒDFS-æ•´ä½“æ˜¯å…ˆåºéå†çš„æ¨¡æ¿
public void dfs(TreeNode root, int level, List<Double> sumList, List<Integer> numberList) {
    // Base case
    if (root == null) return;
    // æ›´æ–°å·²æœ‰çš„è®°å½•
    if (level < sumList.size()) {
        sumList.set(level, sumList.get(level) + root.val);
        numberList.set(level, numberList.get(level) + 1);
        // è¯´æ˜è¿™é‡Œåˆ°äº†ä¸€ä¸ªæ–°çš„å±‚
    } else {
        // åŠ å…¥å…ƒç´ 
        sumList.add(1.0 * root.val);
        numberList.add(1);
    }
    dfs(root.left, level + 1, sumList, numberList);
    dfs(root.right, level + 1, sumList, numberList);
}
```

#### 199.äºŒå‰æ ‘çš„å³è§†å›¾ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/binary-tree-right-side-view)

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„**å³ä¾§**ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›**ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼**ã€‚ç¤ºä¾‹ï¼š

è¾“å…¥: [1, 2, 3, null, 5, null, 4]   è¾“å‡º: [1, 3, 4]

```java
   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

##### 2. é¢˜è§£

###### (1) å¹¿åº¦ä¼˜å…ˆéå†æ³•BFS

å…¶å®å°±æ˜¯ç±»ä¼¼äºŒå‰æ ‘çš„**å±‚åºéå†çš„å¹¿åº¦ä¼˜å…ˆç®—æ³•**ï¼Œåªä¸è¿‡æ¯æ¬¡å¤„ç†çš„æ•°æ®çš„æ—¶å€™ä»…å¤„ç†**è¿™ä¸€å±‚çš„æœ€åä¸€ä¸ªç»“ç‚¹**å³å¯ã€‚ä¾ç„¶é‡‡ç”¨**é˜Ÿåˆ—**è¿›è¡Œè¾…åŠ©ã€‚

```java
public List<Integer> rightSideView(TreeNode root) {
    // Base case
    if(root == null) return new ArrayList<>();
    // ä½¿ç”¨é˜Ÿåˆ—æ¥æ“ä½œå¹¶å°†æ ¹èŠ‚ç‚¹å…¥é˜Ÿåˆ—
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    List<Integer> resList = new ArrayList<>();
    while(!queue.isEmpty()) {
        // å¾—åˆ°å½“å‰å±‚çš„å…ƒç´ ä¸ªæ•°
        int size = queue.size();
        // å¼¹å‡ºå½“å‰å±‚çš„æ‰€æœ‰å…ƒç´ å¹¶å°†å…¶å·¦å³ç»“ç‚¹å…¥é˜Ÿ
        for(int i = 0; i < size; i++) {
            // å¼¹å‡ºèŠ‚ç‚¹
            TreeNode node = queue.poll();
            // æ³¨æ„ï¼å½“ä¸”ä»…å½“å¼¹å‡ºç»“ç‚¹æ˜¯è¿™ä¸€å±‚æœ€åä¸€ä¸ª,ä¹Ÿå°±æ˜¯å³è§†å›¾
            if(i == size - 1) resList.add(node.val);
            if(node.left != null) queue.offer(node.left);
            if(node.right != null) queue.offer(node.right);
        }
    }
    return resList;
}
```

###### (2) æ·±åº¦ä¼˜å…ˆéå†ï¼ˆå‰åºéå†æ–¹å¼ï¼‰

è®¾å®šä¸€ä¸ª**å…¨å±€å˜é‡**è®°å½•å½“å‰æ’å…¥ ans çš„**æœ€å¤§å±‚æ•°**ï¼Œé€’å½’**å…ˆåºéå†å³å­æ ‘**å³å¯å¾—åˆ°**äºŒå‰æ ‘çš„å³è§†å›¾**ã€‚

æ³¨æ„æ•´ä¸ªæ¡†æ¶æ˜¯**å…ˆåºéå†**ï¼å³ç¬¬ä¸€æ¬¡è®¿é—®è¿™ä¸ªç»“ç‚¹æ—¶å°±å¤„ç†æ•°æ®ï¼Œè¿™æ—¶å€™å…ˆåˆ¤æ–­å½“å‰å±‚æ˜¯ä¸æ˜¯æ¯”å½“å‰æœ€å¤§æ·±åº¦é«˜ï¼Œå¦‚æœæ˜¯ï¼Œè¯´æ˜æ˜¯æ–°æ¥åˆ°äº†ä¸€å±‚ï¼Œè€Œä¸”**æ˜¯æ–°çš„ä¸€å±‚çš„æœ€å³è¾¹çš„ç»“ç‚¹**ï¼ˆå› ä¸ºæ˜¯éå†**å³å­æ ‘**ï¼Œæ‰€ä»¥æ˜¯**å…ˆé€’å½’å³å­æ ‘**ï¼‰ã€‚

```java
// å½“å‰æœ€å¤§å±‚æ•°
int level = -1;
List<Integer> resList = new ArrayList<>();

public List<Integer> rightSideView2(TreeNode root) {
    dfs(root, 0);
    return resList;
}

// è¾…åŠ©æ–¹æ³•ï¼šä¼ å…¥æ ¹èŠ‚ç‚¹ï¼Œå±‚æ•°ï¼Œç»“æœé›†
public void dfs(TreeNode root, int level) {
    // Base case
    if (root == null) return;
    // ä»£è¡¨æ˜¯æ–°çš„ä¸€å±‚ï¼Œä»…æ·»åŠ ä¸€æ¬¡
    if (level > this.level) {
        this.level = level;
        resList.add(root.val);
    }
    // å…ˆé€’å½’å³å­æ ‘
    dfs(root.right, level + 1);
    dfs(root.left, level + 1);
}
```

#### 103.ä¹‹å­—å½¢æŒ‰å±‚æ‰“å°äºŒå‰æ ‘ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„**é”¯é½¿å½¢å±‚æ¬¡**éå†ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´**äº¤æ›¿è¿›è¡Œ**ï¼‰ã€‚ä¾‹å¦‚ï¼šç»™å®šäºŒå‰æ ‘ [3, 9, 20, null, null, 15, 7]

```java
   3
  / \
  9  20
    /  \
   15   7
```

è¿”å›é”¯é½¿å½¢å±‚æ¬¡éå†å¦‚ä¸‹ï¼š

```java
[
  [3],
  [20,9],
  [15,7]
]
```

##### 2. é¢˜è§£

###### (1) å¹¿åº¦ä¼˜å…ˆéå†BFS

éƒ½æ˜¯ä¸€ä¸ªå¥—è·¯å•Šï¼Œä¸€å®šè¦è®°ä½ æ™®é€šçš„å±‚åºéå†æ€è·¯ã€‚è¿™ä¸ªé¢˜ä¹Ÿæ˜¯æŒ‰ç…§æ™®é€šçš„å±‚åºéå†ï¼Œ**ç„¶ååŠ ä¸€ä¸ªè®°å½•å±‚æ•°çš„æ ‡å¿—**ï¼Œåˆ¤æ–­æ˜¯åœ¨å•å±‚è¿˜æ˜¯åŒå±‚ï¼Œç„¶åå†³å®šæ˜¯å¦**åè½¬è¿™ä¸€å±‚çš„æ•°æ®**å³å¯ã€‚

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    // Base case
    if(root == null) return new ArrayList<>();
    // ä½¿ç”¨é˜Ÿåˆ—æ¥æ“ä½œï¼Œæ ¹èŠ‚ç‚¹å…¥é˜Ÿåˆ—
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    List<List<Integer>> resList = new ArrayList<>();
    // å½“å‰å±‚æ˜¯å¦éœ€è¦é€†åºçš„æ ‡å¿—ä½
    boolean reverseFlag = false;
    while(!queue.isEmpty()) {
        // å¾—åˆ°å½“å‰å±‚çš„å…ƒç´ ä¸ªæ•°
        int size = queue.size();
        List<Integer> levelList = new ArrayList<>();
        // ä¾æ¬¡å¼¹å‡ºå½“å‰å±‚çš„å…¨éƒ¨èŠ‚ç‚¹å¹¶æ’å…¥levelListä¸­
        for(int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            levelList.add(node.val);
            // å°†å·¦å³å­èŠ‚ç‚¹å…¥é˜Ÿåˆ—
            if(node.left != null) {
                queue.offer(node.left);
            }
            if(node.right != null) {
                queue.offer(node.right);
            }
        }
        // å½“ä¸€å±‚æ•°æ®å¤„ç†å®Œåï¼Œåˆ¤æ–­å½“å‰å±‚æ˜¯å•å±‚è¿˜æ˜¯åŒå±‚ï¼Œå¦‚æœæ˜¯åŒå±‚åˆ™åè½¬æ•°æ®
        if(reverseFlag) {
            Collections.reverse(levelList);
        }
        reverseFlag = !reverseFlag;
        resList.add(levelList);
    }
    return resList;
}
```

#### 515.äºŒå‰æ ‘æ¯å±‚çš„æœ€å¤§å€¼ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row)

æ‚¨éœ€è¦åœ¨äºŒå‰æ ‘çš„**æ¯ä¸€è¡Œä¸­æ‰¾åˆ°æœ€å¤§çš„å€¼**ã€‚è¾“å…¥: 

          1
         / \
        3   2
       / \   \  
      5   3   9 

è¾“å‡º: [1, 3, 9]

##### 2. é¢˜è§£

###### (1) æŒ‰å±‚éå†BFS

æŒ‰ç…§æ™®é€šçš„æŒ‰å±‚éå†æ–¹å¼è¿›è¡Œå±‚åºéå†ï¼Œç„¶å**ç»Ÿè®¡æ¯ä¸€å±‚çš„æœ€å¤§å€¼**å³å¯ã€‚

```java
public List<Integer> largestValues(TreeNode root) {
    // Base case
    if(root == null) return new ArrayList<>();
    List<Integer> resList = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while(!queue.isEmpty()) {
        int size = queue.size();
        // æ³¨æ„ï¼å­˜æ”¾å½“å‰å±‚æœ€å¤§å€¼
        int max = Integer.MIN_VALUE;
        for(int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            // æ³¨æ„:æ›´æ–°æœ€å¤§å€¼
            max = Math.max(max, node.val);
            if(node.left != null) queue.offer(node.left);
            if(node.right != null) queue.offer(node.right);
        }
        resList.add(max);
    }
    return resList;
}
```

###### (2) é€’å½’æ³•DFS

**é€’å½’**æ–¹å¼éå†ï¼Œæ¯æ¬¡åˆ°æŸä¸€å±‚æ—¶åˆ¤æ–­è¿™ä¸ª**ç»“ç‚¹ä¸è¿™ä¸€å±‚å·²æœ‰çš„æœ€å¤§å€¼çš„å¤§å°å…³ç³»**ã€‚æ•´ä½“æ˜¯**å…ˆåºéå†ç»“æ„**ã€‚

```java
private List<Integer> resList = new ArrayList<>();

public List<Integer> largestValues2(TreeNode root) {
    dfs(root, 0);
    return resList;
}

// é€’å½’æ–¹æ³•ï¼šæ•´ä½“æ˜¯å…ˆåºéå†çš„æ¨¡æ¿
public void dfs(TreeNode root, int level) {
    // Base case
    if (root == null) return;
    // å¦‚æœå½“å‰çš„ç»“ç‚¹æ‰€åœ¨çš„å±‚æ˜¯æ–°çš„å±‚ï¼Œåˆ™æ·»åŠ å½“å‰å€¼åˆ°åˆ—è¡¨ä¸­ä½œä¸ºæœ€å¤§å€¼
    if (resList.size() <= level) {
        resList.add(root.val);
        // å¦åˆ™æ˜¯å·²ç»éå†è¿‡çš„å±‚ï¼Œè·å–å·²æœ‰çš„è®°å½•å¹¶åˆ¤æ–­æ˜¯å¦è¦æ›´æ–°æ•°æ®
    } else {
        resList.set(level, Math.max(resList.get(level), root.val));
    }
    // é€’å½’å·¦å³å­æ ‘
    dfs(root.left, level + 1);
    dfs(root.right, level + 1);
}
```

#### 1302.å±‚æ•°æœ€æ·±å¶å­èŠ‚ç‚¹çš„å’Œã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/deepest-leaves-sum/)

ç»™ä½ ä¸€æ£µäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›**å±‚æ•°æœ€æ·±**çš„å¶å­èŠ‚ç‚¹çš„å’Œã€‚

<img src="assets/image-20200422123833181.png" alt="image-20200422123833181" style="zoom:77%;" />

```java
è¾“å…¥ï¼šroot = [1,2,3,4,5,null,6,7,null,null,null,null,8]
è¾“å‡ºï¼š15
```

##### 2. é¢˜è§£

###### (1) BFSå±‚åºéå†æ³•

å±‚åºéå†äºŒå‰æ ‘ï¼Œåˆ©ç”¨ sum æ±‚**æ¯ä¸€è¡Œçš„èŠ‚ç‚¹æ•°ä¹‹å’Œ**ï¼Œæ¯éå†ä¸€å±‚ï¼Œåˆ¤æ–­**é˜Ÿåˆ—æ˜¯å¦è¿˜æœ‰å…ƒç´ **ï¼Œå¦‚æœè¿˜æœ‰è¯´æ˜**è¿˜æ²¡åˆ°æœ€åä¸€å±‚**ï¼Œåˆ™æ¸…ç©º sumï¼Œæ¯”è¾ƒå®¹æ˜“æƒ³åˆ°ã€‚ä¸‹é¢å°±æ˜¯å±‚åºéå†çš„æ¨¡æ¿ã€‚

```java
public int deepestLeavesSum(TreeNode root) {
    // Base case
    if(root == null) return 0;
    // ä¸€å±‚å…ƒç´ çš„å’Œ
    int sum = 0;
    Queue<TreeNode> queue = new LinkedList<TreeNode>() ;
    // æ ¹èŠ‚ç‚¹å…¥é˜Ÿåˆ—
    queue.add(root);
    // é˜Ÿåˆ—ä¸ºç©ºæ—¶æ¨é€€å‡ºå¾ªç¯
    while(queue.size() != 0) {
        // è·å–å½“å‰é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ªæ•°ï¼Œä¹Ÿå°±æ˜¯å½“å‰è¿™ä¸€å±‚æœ‰å¤šå°‘ä¸ªç»“ç‚¹
        int size = queue.size();
        // æ–°çš„ä¸€å±‚é‡ç½®ä¸€æ¬¡sum
        sum = 0;
        // å°†å½“å‰å±‚çš„å…ƒç´ ä¾æ¬¡å‡ºé˜Ÿåˆ—å¹¶å¤„ç†æ•°æ®ï¼Œæ¯å¼¹å‡ºä¸€ä¸ªç»“ç‚¹å¹¶å†æ¬¡å°†å…¶å·¦å³å­èŠ‚ç‚¹å…¥é˜Ÿåˆ—
        for(int i = 0; i < size; i++) {
            // å‡ºé˜Ÿåˆ—å¹¶å¤„ç†æ•°æ®
            TreeNode temp = queue.poll();
            // æ±‚è¿™ä¸€å±‚çš„å…ƒç´ ä¹‹å’Œ
            sum = sum + temp.val;
            // å°†å‡ºé˜Ÿç»“ç‚¹çš„å·¦å³å­èŠ‚ç‚¹å…¥é˜Ÿ
            if(temp.left != null) queue.add(temp.left);
            if(temp.right != null) queue.add(temp.right);
        }
    }
    return sum;
}
```

###### (2) é€’å½’æ³•DFS

ä½¿ç”¨**é€’å½’**çš„æ–¹å¼ï¼Œéœ€è¦ç»´æŠ¤ sum ä¸**æ·±åº¦çš„å…¨å±€å˜é‡**ã€‚æ•´ä¸ªæ¡†æ¶æ˜¯å±äº**å‰åºéå†**çš„æ¡†æ¶ã€‚åªæ˜¯å¤„ç†æ•°æ®çš„æ—¶å€™æºå¸¦ä¸Šäº†**å·²ç»éå†çš„æ·±åº¦å€¼**ã€‚è¿™ä¸ªé€’å½’çš„æ¨¡æ¿ä¹Ÿç±»ä¼¼ã€‚

```java
// ç»“ç‚¹å’Œ
private int sum = 0;

// äºŒå‰æ ‘æœ€å¤§æ·±åº¦
private int deepLevel = 0;
public int deepestLeavesSum2(TreeNode root) {
    // å½“å‰æ·±åº¦ä¸º0
    dfs(root, 0);
    return sum;
}

private void dfs(TreeNode node, int level){
    // Base case
    if (node == null) return;
    // å½“å‰å±‚ç­‰äºå·²ç»æ¥çš„æ·±åº¦
    if (level == deepLevel) {
        sum = sum + node.val;
        // å¦‚æœæœ‰æ›´æ·±çš„æ·±åº¦åˆ™æ›´æ–°sumå’Œæœ€å¤§æ·±åº¦deep
    } else if (level > deepLevel){
        sum = node.val;
        deepLevel = level;
    }
    // é€’å½’å·¦å­æ ‘å’Œå³å­æ ‘
    dfs(node.left, level + 1);
    dfs(node.right, level + 1);
}
```

#### 513.æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/find-bottom-left-tree-value)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåœ¨æ ‘çš„**æœ€åä¸€è¡Œæ‰¾åˆ°æœ€å·¦è¾¹çš„å€¼**ã€‚è¾“å…¥:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

è¾“å‡ºï¼š

```java
7
```

##### 2. é¢˜è§£

###### (1) å±‚åºéå†æ³•

å¯ä»¥æŒ‰ç…§**å±‚åºçš„æ¨¡æ¿æ±‚æœ€åçš„ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹**ã€‚è¿™ä¸ªå°±æ¯”è¾ƒç®€å•äº†ï¼Œåªéœ€è¦åš**ä¸€ç‚¹ä¿®æ”¹å³å¯**ã€‚

```java
public int findBottomLeftValue(TreeNode root) {

    // Base case
    if(root == null) return 0;
    int res = Integer.MAX_VALUE;
    // æ ¹èŠ‚ç‚¹å…¥é˜Ÿåˆ—
    Queue<TreeNode> queue = new LinkedList<TreeNode>() ;
    queue.add(root);
    // é˜Ÿåˆ—ä¸ºç©ºæ—¶é€€å‡ºå¾ªç¯
    while(queue.size() != 0) {
        int size = queue.size();
        for(int i = 0; i < size; i++) {
            TreeNode temp = queue.poll();
            // å…³é”®æ­¥éª¤ï¼ï¼è®°å½•æ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªæ•°ï¼ï¼ï¼ï¼ï¼ï¼
            if(i == 0) {
                res = temp.val;
            }
            // å°†å‡ºé˜Ÿç»“ç‚¹çš„å·¦å³å­èŠ‚ç‚¹å…¥é˜Ÿ
            if(temp.left != null) queue.add(temp.left);
            if(temp.right != null) queue.add(temp.right);
        }
    }
    return res;
}
```

###### (2) é€’å½’æ³• DFS

å…¶å®å°±æ˜¯æ±‚**æœ€åä¸€è¡Œ**çš„**ç¬¬ä¸€ä¸ªèŠ‚ç‚¹**ã€‚åˆ©ç”¨**é€’å½’æ–¹å¼**ï¼šæ•´ä½“é‡‡ç”¨**å…ˆåºéå†**çš„æ–¹å¼ï¼ŒåŒæ—¶ç»´æŠ¤**ä¸¤ä¸ªå˜é‡**ï¼Œä¸€ä¸ªæ˜¯**æŸä¸€å±‚ç¬¬ä¸€ä¸ª**æ•°çš„å€¼ï¼Œå¦ä¸€ä¸ªæ˜¯å½“å‰éå†åˆ°çš„**æœ€æ·±çš„é«˜åº¦**ã€‚å½“**ç¬¬ä¸€æ¬¡**å½“å‰å±‚**å¤§äº**ç›®å‰éå†åˆ°çš„**æœ€æ·±çš„å±‚**çš„æ—¶å€™**æ›´æ–°æ•°æ®**ï¼Œç”±äºæ˜¯å…ˆåºéå†ï¼Œæ‰€ä»¥ä¸€å®šæ˜¯æ¯è¡Œå·¦è¾¹ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¼€å¯æ–°çš„ä¸€è¡Œã€‚

```java
// æœ€ç»ˆçš„ç»“æœ
int res = Integer.MIN_VALUE;
// å½“å‰å·²ç»éå†çš„æœ€æ·±å±‚æ•°
int deepLevel = 0;

public int findBottomLeftValue2(TreeNode root) {
    // ä»ç¬¬ä¸€å±‚å¼€å§‹
    helper(root, 1);
    return res;
}

// è¾…åŠ©å‡½æ•°ï¼šä¼ å…¥æ ¹èŠ‚ç‚¹ä»¥åŠå½“å‰æ‰€åœ¨çš„å±‚æ•°
private void helper(TreeNode root, int level) {
    // Base case
    if(root == null) return;
    // å½“ç¬¬ä¸€æ¬¡å½“å‰å±‚å¤§äºç›®å‰éå†åˆ°çš„æœ€æ·±çš„å±‚çš„æ—¶å€™æ›´æ–°æ•°æ®
    // ç”±äºæ˜¯å…ˆåºéå†ï¼Œæ‰€ä»¥ä¸€å®šæ˜¯æ¯è¡Œå·¦è¾¹ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¼€å¯æ–°çš„ä¸€è¡Œ
    if(level > deepLevel) {
        // æ›´æ–°æœ€æ·±çš„å±‚æ•°
        deepLevel = level;
        // æ›´æ–°reså€¼
        res = root.val;
    }
    // é€’å½’å·¦å³å­æ ‘å¹¶æ·±åº¦+1
    helper(root.left, level + 1);
    helper(root.right, level + 1);
}
```



### äºŒå‰æ ‘ç‰¹å¾åˆ¤æ–­é—®é¢˜

#### 958.åˆ¤æ–­æ˜¯å¦æ˜¯å®Œå…¨äºŒå‰æ ‘ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œç¡®å®šå®ƒæ˜¯å¦æ˜¯ä¸€ä¸ª**å®Œå…¨äºŒå‰æ ‘**ã€‚

##### 2. é¢˜è§£

###### (1) å±‚åºéå†æ³•

- **æŒ‰å±‚éå†**ï¼Œæ¯å±‚éƒ½**ä»å·¦åˆ°å³**è¿›è¡Œéå†ï¼ˆæ‰€ä»¥æ•´ä½“æ˜¯**å±‚åº BFS éå†**çš„æ¡†æ¶ï¼Œåªæ˜¯åŠ äº†ä¸€äº›é€»è¾‘ï¼‰ã€‚
- å¦‚æœå½“å‰èŠ‚ç‚¹æœ‰å³å­èŠ‚ç‚¹ä½†æ˜¯æ²¡æœ‰å·¦å­èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å› falseã€‚
- å¦‚æœå½“å‰èŠ‚ç‚¹**å¹¶ä¸æ˜¯å·¦å³å­©å­éƒ½æœ‰**ï¼Œé‚£ä¹ˆä¹‹åçš„**èŠ‚ç‚¹å¿…é¡»å…¨éƒ½ä¸ºå¶å­ç»“ç‚¹**ï¼Œå¦åˆ™è¿”å› falseã€‚
- **ç»´æŠ¤ä¸€ä¸ªæ ‡å¿—ä½ï¼Œæ ‡å¿—é‡åˆ°ç¬¬ä¸€ä¸ªä¸æ˜¯å·¦å³å­©å­éƒ½æœ‰çš„ç»“ç‚¹æ—¶æ‰“å¼€ã€‚**

```java
public boolean isCompleteTree(TreeNode head) {

    if (head == null) return true;
    // ä½¿ç”¨é˜Ÿåˆ—æ¥è¿›è¡Œå±‚åºéå†å¹¶åŠ å…¥æ ¹ç»“ç‚¹
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(head);
    // åé¢çš„ç»“ç‚¹æ˜¯å¦å¿…é¡»å…¨ä¸ºå¶å­ç»“ç‚¹çš„æ ‡å¿—
    boolean isMeetLeaf = false;
    // å®šä¹‰ä¸¤ä¸ªèŠ‚ç‚¹
    TreeNode left, right;
    while (!queue.isEmpty()) {
        // å¼¹å‡ºèŠ‚ç‚¹å¹¶è¿›è¡Œåˆ¤æ–­
        head = queue.poll();
        left = head.left;
        right = head.right;
        // ä¸ç¬¦åˆæ¡ä»¶ç›´æ¥false
        if ((isMeetLeaf && (left != null || right != null) ||
             left == null && right != null)) {
            return false;
        }
        if (left != null) {
            queue.offer(left);
        }
        if (right != null) {
            queue.offer(right);
        } else {
            // é‡åˆ°ç¬¬ä¸€ä¸ªä¸æ˜¯å…¨æœ‰å·¦å³å­èŠ‚ç‚¹çš„ç»“ç‚¹ åˆ™åé¢çš„å…¨éƒ¨èŠ‚ç‚¹å¿…é¡»ä¸ºå¶å­ç»“ç‚¹
            isMeetLeaf = true;
        }
    }
    // ä¸Šè¿°æ²¡æœ‰è¿”å›falseåˆ™ä¸ºtrue
    return true;
}
```

**å†æ¥ä¸€ç§å±‚åºéå†çš„è§£æ³•**ï¼šæŠŠä¸€é¢—æ ‘çš„èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬ç©ºèŠ‚ç‚¹ï¼‰æŒ‰**å±‚åºéå†æ’æˆä¸€è¡Œ**ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ä¸¤ä¸ªç›¸é‚»èŠ‚ç‚¹ï¼š**å‰ä¸€ä¸ªä¸ºnullï¼Œåä¸€ä¸ªä¸ä¸º null æ—¶ï¼Œæ‰ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘**ã€‚é¢è¯•ç”¨è¿™ä¸ªï¼ä¾‹å¦‚ï¼š

```java
       1
      / \
     2   3
    / \   \
   4   5  6
Â  / \    / 
 7   8  9  
å±‚åºéå†åºåˆ—ä¸ºï¼š[1, 2, 3, 4, 5, 6, 7, 8, null, null, 9]ï¼Œå…¶ä¸­ null å‡ºç°åœ¨äº†9å‰é¢ï¼Œæ‰€ä»¥ä¸åˆæ³•
```

```java
public boolean isCompleteTree2(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    TreeNode cur = root;
    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        // ä¸¤ä¸ªéƒ½ä¸ºnullåˆ™ç›´æ¥è¿”å›
        if (cur == null && node != null) return false;
        // æ»šåŠ¨æ›´æ–°cur
        cur = node;
        // æŠŠå·¦å³éƒ½åŠ å…¥queue,nullä¹ŸåŠ å…¥
        if (node != null) {
            queue.add(node.left);
            queue.add(node.right);
        }
    }
    return true;
}
```

åˆ©ç”¨å®Œå…¨äºŒå‰æ ‘å±‚åºéå†æ—¶èŠ‚ç‚¹è¿ç»­å‡ºç°çš„æ€§è´¨ï¼Œéå†**åˆ° null ä¹‹åå†éå†åˆ°é null åˆ™è¯´æ˜ä¸è¿ç»­**ã€‚

#### 110.åˆ¤æ–­æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/balanced-binary-tree)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯**é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘**ã€‚æœ¬é¢˜ä¸­ä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æ ‘å®šä¹‰ä¸ºï¼šä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„**ç»å¯¹å€¼ä¸è¶…è¿‡ 1**ã€‚

**ç¤ºä¾‹ 1:** ç»™å®šäºŒå‰æ ‘ [3, 9, 20, null, null, 15, 7]

```java
    3
   / \
  9  20
    /  \
   15   7
```

è¿”å› true ã€‚

**ç¤ºä¾‹ 2:** ç»™å®šäºŒå‰æ ‘ [1,2,2,3,3,null,null,4,4]

```java
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```

è¿”å› false ã€‚

##### 2. é¢˜è§£

###### (1) è‡ªåº•å‘ä¸Šæš´åŠ›é€’å½’æ³•

ç›´æ¥ä½¿ç”¨**æ ‘å½¢ dp å¥—è·¯**æ±‚è§£ã€‚ç»´æŠ¤ä¸€ä¸ª **æ˜¯å¦å¹³è¡¡** çš„æ ‡å¿—ä½ï¼Œé€’å½’å‡½æ•°è¿”å›**å½“å‰èŠ‚ç‚¹çš„æœ€å¤§é«˜åº¦å€¼**ã€‚é€’å½’æ—¶é‡åˆ°ä¸å¹³è¡¡çš„æƒ…å†µç›´æ¥æ›´æ–°æ ‡å¿—ä½ã€‚

```java
// è®°å½•æ˜¯å¦å¹³è¡¡
private boolean balance = true;

public boolean isBalanced(TreeNode root) {
    process(root);
    return balance;
}

// æ ‘å½¢dpçš„æ¨¡æ¿
private int process(TreeNode root) {
    // èŠ‚ç‚¹ä¸ºnullè¿”å›é«˜åº¦ä¸º0
    if(root == null) return 0;
    // è·å–å·¦å³å­æ ‘çš„é«˜åº¦ä¿¡æ¯
    int leftHeight = process(root.left);
    int rightHeight = process(root.right);
    // åˆ©ç”¨å·¦å³å­æ ‘çš„é«˜åº¦ä¿¡æ¯åˆ¤æ–­æ˜¯å¦å¹³è¡¡
    if(Math.abs(leftHeight - rightHeight) > 1) {
        // ç›´æ¥æ›´æ–°ä¸å¹³è¡¡ç»“æœ
        balance = false;
    }
    // æ„é€ è‡ªå·±çš„é«˜åº¦ä¿¡æ¯ï¼šå³å½“å‰èŠ‚ç‚¹çš„æœ€å¤§é«˜åº¦å€¼ï¼ˆåŒæ—¶éœ€è¦åŠ ä¸Šè‡ªå·±çš„é«˜åº¦1ï¼‰
    return Math.max(leftHeight, rightHeight) + 1;
}
```

#### ğŸ’¯104.æ±‚äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

è¾“å…¥ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œæ±‚è¯¥æ ‘çš„æ·±åº¦ã€‚ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹ä¾æ¬¡ç»è¿‡çš„èŠ‚ç‚¹ï¼ˆå«æ ¹ã€å¶èŠ‚ç‚¹ï¼‰å½¢æˆæ ‘çš„ä¸€æ¡è·¯å¾„ï¼Œ**æœ€é•¿**è·¯å¾„çš„é•¿åº¦ä¸ºæ ‘çš„æ·±åº¦ã€‚

ä¾‹å¦‚ï¼šç»™å®šäºŒå‰æ ‘ [3, 9, 20, null, null, 15, 7]

        3
       / \
      9  20
        /  \
       15   7

è¿”å›å®ƒçš„æœ€å¤§æ·±åº¦ 3 ã€‚

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•DFS(ååºéå†)

æ ‘å½¢ dp å¥—è·¯æ±‚è§£ï¼Œä½†æ˜¯æ­¤å¤„çš„**è¿”å›å€¼å°±åªæœ‰æ·±åº¦å€¼** æœ¬èº«ï¼Œå…¶å®éƒ½ä¸ç”¨é¢å¤–æ„é€ è¿”å›çš„æ•°æ®ç»“æ„äº†ã€‚æ ‘çš„ååºéå† / æ·±åº¦ä¼˜å…ˆæœç´¢å¾€å¾€åˆ©ç”¨ **é€’å½’ æˆ– æ ˆ** å®ç°ï¼Œæœ¬æ–‡ä½¿ç”¨**é€’å½’**å®ç°ã€‚**å…³é”®ç‚¹**ï¼š æ­¤æ ‘çš„æ·±åº¦å’Œå…¶å·¦ï¼ˆå³ï¼‰å­æ ‘çš„æ·±åº¦ä¹‹é—´çš„**å…³ç³»**ã€‚æ˜¾ç„¶ï¼Œæ­¤æ ‘çš„æ·±åº¦ ç­‰äº å·¦å­æ ‘çš„æ·±åº¦ ä¸ å³å­æ ‘çš„æ·±åº¦ ä¸­çš„ **æœ€å¤§å€¼ +1** ã€‚

```java
public int maxDepth(TreeNode root) {
    // Base case
    if(root == null) return 0;
    // é»˜è®¤ä»å·¦å³è·å–ä¿¡æ¯
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    // æ„é€ è‡ªå·±çš„é«˜åº¦ä¿¡æ¯
    return Math.max(left, right) + 1;
}
```

ç®€åŒ–ä¸€ç‚¹ï¼š

```java
public int maxDepth(TreeNode root) {
    if(root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

###### (2) å±‚åºéå†(BFS)

å°±æ˜¯æ™®é€šçš„**å±‚åºéå†æ¨¡æ¿**ã€‚æ ‘çš„å±‚åºéå† / å¹¿åº¦ä¼˜å…ˆæœç´¢å¾€å¾€åˆ©ç”¨ **é˜Ÿåˆ—** å®ç°ã€‚**å…³é”®ç‚¹ï¼š** æ¯éå†ä¸€å±‚ï¼Œåˆ™è®¡æ•°å™¨ +1 ï¼Œç›´åˆ°**éå†å®Œæˆ**ï¼Œåˆ™å¯å¾—åˆ°æ ‘çš„æ·±åº¦ã€‚è¿™ç§æ–¹å¼æ…¢ä¸€ç‚¹åªèƒ½å‡»è´¥ 20%ï¼Œä½†æ˜¯**é¢è¯•ç»å¸¸è€ƒéé€’å½’**ã€‚

```java
public int maxDepth(TreeNode root) {
    // Base case
    if(root == null) return 0;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int depth = 0;
    while(!queue.isEmpty()){
        // æ³¨æ„!é«˜åº¦+1
        depth++;
        int size = queue.size();
        // å¼¹å‡ºå½“å‰è¿™ä¸€å±‚çš„å…ƒç´ ï¼Œå¹¶æŠŠå…¶å·¦å³å­èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­
        while (size-- > 0){
            TreeNode node =  queue.poll();
            if(node.left != null) queue.offer(node.left);
            if(node.right != null) queue.offer(node.right);
        }
    }
    return depth;
}
```

#### 111.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚æœ€å°æ·±åº¦æ˜¯**ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹**çš„**æœ€çŸ­è·¯å¾„**ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚è¯´æ˜ï¼šå¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚ç¤ºä¾‹ï¼šç»™å®šäºŒå‰æ ‘ [3, 9, 20, null, null, 15, 7]ã€‚

```java
    3
   / \
  9  20
    /  \
   15   7
```

è¿”å›å®ƒçš„æœ€å°æ·±åº¦  2ã€‚

##### 2. é¢˜è§£

###### (1) è‡ªåº•å‘ä¸Šæš´åŠ›é€’å½’æ³•

ç›´æ¥ä½¿ç”¨**æš´åŠ›é€’å½’**éå¸¸ easyã€‚

```java
public int minDepth(TreeNode root) {
    // Base case
    if(root == null) return 0;
    // ç›´æ¥è·å–å·¦è¾¹çš„ä¿¡æ¯å’Œå³è¾¹ä¿¡æ¯
    int minLeft = minDepth(root.left);
    int minRight = minDepth(root.right);
    // æ„é€ è‡ªå·±çš„è¿”å›ä¿¡æ¯
    if(minLeft != 0 && minRight == 0) {
        return minLeft + 1;
    }
    if(minLeft == 0 && minRight != 0) {
        return minRight + 1;
    }
    // å·¦å³é«˜åº¦è¾ƒå°çš„+1
    return Math.min(minLeft, minRight) + 1;
}
```

###### (2) é€’å½’æ³•DFS

ç›´æ¥åˆ©ç”¨é€’å½’æ³•æ±‚ï¼Œç±»ä¼¼äºå±‚åºéå†éƒ¨åˆ†ä¸­å¸¸è§çš„é€’å½’æ³•å¥—è·¯ï¼Œä¹Ÿå°±æ˜¯ç»´æŠ¤ä¸€ä¸ª**å±‚æ•°å˜é‡**ï¼Œ**æ¯æ¬¡é‡åˆ°å¶å­èŠ‚ç‚¹**çš„æ—¶å€™åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦éœ€è¦æ›´æ–°æœ€å°æ·±åº¦ã€‚**ç¬”è¯•è¿™ä¸ªå³å¯**ã€‚

```java
// è®°å½•æœ€å°å€¼
int minDepth = Integer.MAX_VALUE;
public int minDepth2(TreeNode root) {
    if(root == null) return 0;
    dfs(root, 1);
    return minDepth;
}

// é€’å½’-æ•´ä½“å…ˆåºéå†æ¶æ„
private void dfs(TreeNode root, int level) {
    if(root == null) return;
    // å¦‚æœå½“å‰æ˜¯ä¸€ä¸ªå¶å­èŠ‚ç‚¹å°±åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°æœ€å°æ·±åº¦
    if(root.left == null && root.right == null) {
        minDepth = Math.min(minDepth, level);
    }
    dfs(root.left, level + 1);
    dfs(root.right, level + 1);
}
```

###### (3) å±‚åºéå†BFS

å‰é¢**æ·±åº¦ä¼˜å…ˆæœç´¢æ–¹æ³•**çš„**ç¼ºé™·**æ˜¯**æ‰€æœ‰èŠ‚ç‚¹**éƒ½å¿…é¡»è®¿é—®åˆ°ï¼Œä»¥ä¿è¯èƒ½å¤Ÿæ‰¾åˆ°æœ€å°æ·±åº¦ã€‚å› æ­¤å¤æ‚åº¦æ˜¯ O(N) ã€‚ä¸€ä¸ª**ä¼˜åŒ–**çš„æ–¹æ³•æ˜¯åˆ©ç”¨**å¹¿åº¦ä¼˜å…ˆæœç´¢**ï¼ŒæŒ‰ç…§æ ‘çš„**å±‚åºéå†**ï¼Œ**==ç¬¬ä¸€ä¸ªè®¿é—®åˆ°çš„å¶å­å°±æ˜¯æœ€å°æ·±åº¦çš„èŠ‚ç‚¹==**ï¼Œè¿™æ ·å°±ä¸ç”¨éå†æ‰€æœ‰çš„èŠ‚ç‚¹äº†ã€‚

```java
public int minDepth(TreeNode root) {
    if(root == null) return 0;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    // æ³¨æ„ï¼šè®°å½•æœ€ä½å±‚æ•°çš„å˜é‡
    int minDepth = 0;
    while (!queue.isEmpty()) {
        // åˆ°äº†æ–°çš„ä¸€å±‚ï¼Œå±‚æ•°++
        minDepth++;

        int levelSize = queue.size();
        while (levelSize-- > 0) {
            TreeNode node = queue.poll();
            // å¦‚æœå½“å‰æ˜¯å¶å­èŠ‚ç‚¹å°±ç›´æ¥é€€å‡º
            if (node.left == null && node.right == null) {
                return minDepth;
            }
            if(node.left != null) queue.add(node.left);
            if(node.right != null) queue.add(node.right);
        }
    }
    return minDepth;
}
```



#### 559.Nå‰æ ‘çš„æœ€å¤§æ·±åº¦ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

ç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œæ‰¾åˆ°å…¶æœ€å¤§æ·±åº¦ã€‚æœ€å¤§æ·±åº¦æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ€»æ•°ã€‚ä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ª 3å‰æ ‘ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ 3ã€‚

<img src="assets/image-20200421094921748.png" alt="image-20200421094921748" style="zoom:40%;" />

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

ä¹Ÿæ˜¯ä½¿ç”¨é€’å½’æ³•ï¼Œä¹Ÿæ˜¯ç”¨**æš´åŠ›é€’å½’**å³å¯ã€‚è¿‡ç¨‹ä¸å¤šè¯´äº†ï¼Œåªæ˜¯è·å–é»˜è®¤ä¿¡æ¯çš„æ—¶å€™é»˜è®¤æ˜¯ä»**å…¨éƒ¨çš„å­æ ‘è·å–**çš„ä¿¡æ¯ã€‚

```java
public int maxDepth(Node root) {
    // Base caseï¼šä¸ºnullé€€å‡º
    if(root == null) return 0;
    // å½“ä¸ºå¶å­ç»“ç‚¹ç›´æ¥è¿”å›1
    if(root.children == null || root.children.size() == 0) {
        return 1;
    }
    // ä½¿ç”¨åˆ—è¡¨å­˜å‚¨å„ä¸ªå­æ ‘çš„é«˜åº¦ä¿¡æ¯å€¼
    List<Integer> heightList = new ArrayList();
    // è·å–å„ä¸ªå­æ ‘çš„é«˜åº¦ä¿¡æ¯å¹¶å­˜å…¥åˆ—è¡¨
    for(Node head : root.children) {
        heightList.add(maxDepth(head));
    }
    // è¿”å›å„ä¸ªå­æ ‘æœ€å¤§çš„é«˜åº¦+1
    return Collections.max(heightList) + 1;
}
```

```java
int maxDepth = 0;
public int maxDepth(Node root) {
    if (root == null) return 0;
    dfs(root, 1);
    return maxDepth;
}

private void dfs(Node root, int level) {
    if (root == null) return;
    if(root.children == null || root.children.size() == 0) {
        maxDepth = Math.max(maxDepth, level);
    }
    for (Node node : root.children) {
        dfs(node, level + 1);
    }
}
```

###### (2) å±‚åºéå†BFS

ä¹Ÿå¯ä»¥å¥—ç”¨**å±‚åºéå†**çš„æ¨¡æ¿æ±‚è§£ã€‚è¿™é‡Œå°±ä¸æ”¾ä»£ç äº†ã€‚

#### ğŸ’¯101.å¯¹ç§°äºŒå‰æ ‘ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/symmetric-tree)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯**é•œåƒå¯¹ç§°**çš„ã€‚ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1, 2, 2, 3, 4, 4, 3] æ˜¯å¯¹ç§°çš„ã€‚

        1
       / \
      2   2
     / \ / \
    3  4 4  3

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•DFS

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    // è°ƒç”¨é€’å½’å‡½æ•°ï¼Œæ¯”è¾ƒå·¦èŠ‚ç‚¹ï¼Œå³èŠ‚ç‚¹
    return dfs(root.left, root.right);
}

boolean dfs(TreeNode left, TreeNode right) {
    // é€’å½’çš„ç»ˆæ­¢æ¡ä»¶æ˜¯ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸ºç©º
    // æˆ–è€…ä¸¤ä¸ªèŠ‚ç‚¹ä¸­æœ‰ä¸€ä¸ªä¸ºç©º
    // æˆ–è€…ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼ä¸ç›¸ç­‰
    if (left == null && right == null) return true;
    if (left == null || right == null) return false;
    if (left.val != right.val) return false;
    // å†é€’å½’çš„æ¯”è¾ƒå·¦èŠ‚ç‚¹çš„å·¦å­©å­å’Œå³èŠ‚ç‚¹çš„å³å­©å­
    // ä»¥åŠæ¯”è¾ƒå·¦èŠ‚ç‚¹çš„å³å­©å­å’Œå³èŠ‚ç‚¹çš„å·¦å­©å­
    return dfs(left.left, right.right) && dfs(left.right, right.left);
}
```

#### 872.å¶å­ç›¸ä¼¼çš„æ ‘ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/leaf-similar-trees)

è¯·è€ƒè™‘ä¸€é¢—äºŒå‰æ ‘ä¸Š**æ‰€æœ‰çš„å¶å­**ï¼Œè¿™äº›å¶å­çš„å€¼æŒ‰**ä»å·¦åˆ°å³**çš„é¡ºåºæ’åˆ—å½¢æˆä¸€ä¸ª **å¶å­å€¼åºåˆ—** ã€‚

<img src="assets/image-20200425090539254.png" alt="image-20200425090539254" style="zoom:40%;" />

ä¸¾ä¸ªä¾‹å­å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œç»™å®šä¸€é¢—å¶å€¼åºåˆ—ä¸º **(6, 7, 4, 9, 8)** çš„æ ‘ã€‚å¦‚æœæœ‰ä¸¤é¢—äºŒå‰æ ‘çš„**å¶å€¼åºåˆ—æ˜¯ç›¸åŒ**ï¼Œé‚£ä¹ˆå°±è®¤ä¸ºå®ƒä»¬æ˜¯ **å¶ç›¸ä¼¼** çš„ã€‚å¦‚æœç»™å®šçš„ä¸¤ä¸ªå¤´ç»“ç‚¹åˆ†åˆ«ä¸º root1 å’Œ root2 çš„æ ‘æ˜¯å¶ç›¸ä¼¼çš„ï¼Œåˆ™è¿”å› trueï¼›å¦åˆ™è¿”å› false ã€‚

##### 2. é¢˜è§£

###### (1) DFSéå†å¶å­èŠ‚ç‚¹æ³•

é¦–å…ˆåˆ†åˆ«æ‰¾å‡ºç»™å®šçš„ä¸¤ä¸ªæ ‘çš„å¶å€¼åºåˆ—ã€‚ä¹‹åå¯ä»¥æ¯”è¾ƒå®ƒä»¬çœ‹çœ‹æ˜¯å¦ç›¸ç­‰ã€‚è¦æ‰¾å‡ºæ ‘çš„å¶å€¼åºåˆ—ï¼Œå¯ä»¥ä½¿ç”¨ DFSã€‚å¦‚æœç»“ç‚¹æ˜¯**å¶å­**ï¼Œé‚£ä¹ˆ dfs å‡½æ•°ä¼š**å†™å…¥ç»“ç‚¹çš„å€¼**ï¼Œç„¶å**é€’å½’**åœ°æ¢ç´¢æ¯ä¸ªå­ç»“ç‚¹ã€‚è¿™å¯ä»¥ä¿è¯æŒ‰**ä»å·¦åˆ°å³çš„é¡ºåº**è®¿é—®æ¯ç‰‡å¶å­ï¼Œå› ä¸ºåœ¨å³å­©å­ç»“ç‚¹ä¹‹å‰å®Œå…¨æ¢ç´¢äº†å·¦å­©å­ç»“ç‚¹ã€‚

```java
public boolean leafSimilar(TreeNode root1, TreeNode root2) {
    List<Integer> leaves1 = new ArrayList();
    List<Integer> leaves2 = new ArrayList();
    dfs(root1, leaves1);
    dfs(root2, leaves2);
    return leaves1.equals(leaves2);
}

// æ•´ä½“æ˜¯å…ˆåºéå†çš„æ¶æ„
public void dfs(TreeNode node, List<Integer> leafValues) {
    if (node == null) return;
    // æ·±åº¦ä¼˜å…ˆéå†æ ‘ï¼Œå°†å¶å­èŠ‚ç‚¹å€¼ä¿å­˜
    if (node.left == null && node.right == null) {
        leafValues.add(node.val);
    }
    dfs(node.left, leafValues);
    dfs(node.right, leafValues);
}
```

####  965.å•å€¼äºŒå‰æ ‘ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/univalued-binary-tree/)

å¦‚æœäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹**éƒ½å…·æœ‰ç›¸åŒçš„å€¼**ï¼Œé‚£ä¹ˆè¯¥äºŒå‰æ ‘å°±æ˜¯å•å€¼äºŒå‰æ ‘ã€‚åªæœ‰ç»™å®šçš„æ ‘æ˜¯å•å€¼äºŒå‰æ ‘æ—¶ï¼Œæ‰è¿”å› `true`ï¼›å¦åˆ™è¿”å› `false`ã€‚

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

ä¸€æ£µæ ‘æ˜¯**å•å€¼**çš„ï¼Œè¯´æ˜åé¢çš„**æ¯ä¸€ä¸ªç»“ç‚¹å€¼éƒ½ä¸æ ¹èŠ‚ç‚¹å€¼ä¸€æ ·**ã€‚é¦–å…ˆä¿å­˜æ ¹èŠ‚ç‚¹å€¼ï¼Œç„¶åä¾æ¬¡åˆ¤æ–­æ˜¯ä¸æ˜¯ç›¸åŒçš„å³å¯ã€‚æ•´ä½“æ˜¯å…ˆåºéå†ã€‚

```java
int value;
public boolean isUnivalTree(TreeNode root) {
    if(root == null) return false;
    // é¦–å…ˆä¿å­˜æ ¹èŠ‚ç‚¹çš„å€¼
    value = root.val;
    return process(root);
}

private boolean process(TreeNode root) {
    // Base case
    if(root == null) return true;
    // å¦‚æœè¿™ä¸ªå€¼ä¸æ ¹èŠ‚ç‚¹ä¸åŒåˆ™ä¸æ˜¯å•å€¼çš„
    if(root.val != value) return false;
    // è·å–å·¦å³å­æ ‘çš„ä¿¡æ¯
    boolean left = process(root.left);
    boolean right = process(root.right);
    // å¿…é¡»å·¦å³å­æ ‘éƒ½ä¸ºtrueæ‰æ˜¯true
    return left && right;
}
```

å†æ¥ä¸€ç§**é€’å½’å†™æ³•**ã€‚

```java
boolean res = true;
int rootVal = 0;
public boolean isUnivalTree(TreeNode root) {
    if(root == null) return false;
    rootVal = root.val;
    // é¦–å…ˆä¿å­˜æ ¹èŠ‚ç‚¹çš„å€¼
    process(root);
    return res;
}

private void dfs(TreeNode root) {
    // Base case
    if(root == null) return;
    // å¦‚æœè¿™ä¸ªå€¼ä¸æ ¹èŠ‚ç‚¹ä¸åŒåˆ™ä¸æ˜¯å•å€¼çš„
    if(root.val != rootVal) res = false;
    // è·å–å·¦å³å­æ ‘çš„ä¿¡æ¯
    dfs(root.left);
    dfs(root.right);
}
```

#### 100.ç›¸åŒçš„æ ‘ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/same-tree)

ç»™å®šä¸¤ä¸ªäºŒå‰æ ‘ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€éªŒ**å®ƒä»¬æ˜¯å¦ç›¸åŒ**ã€‚å¦‚æœä¸¤ä¸ªæ ‘åœ¨**ç»“æ„ä¸Šç›¸åŒ**ï¼Œå¹¶ä¸”èŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„å€¼ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚ç¤ºä¾‹ 1ï¼šè¾“å…¥ï¼š[1,2,3],   [1,2,3]

               1         1
              / \       / \
             2   3     2   3

è¾“å‡º: true

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

è¿™ä¸ªé¢˜æ˜¯å…¸å‹çš„æ“ä½œä¸¤æ£µæ ‘çš„é¢˜ç›®ï¼Œç›´æ¥ä½¿ç”¨**é€’å½’**çš„æ–¹å¼è¿›è¡Œåˆ¤æ–­å³å¯ã€‚æ•´ä½“æ˜¯**å…ˆåºéå†**ã€‚

```java
public boolean isSameTree2(TreeNode root2, TreeNode root2) {
    // Base case å¦‚æœä¸¤ä¸ªéƒ½ä¸ºç©ºè¿”å›true
    if(root2 == null && root2 == null) return true;
    // å¦‚æœå…¶ä¸­ä¸€ä¸ªç»“ç‚¹ä¸ºç©ºæˆ–è€…ä¸¤ä¸ªçš„å€¼ä¸åŒï¼Œè¿”å›false
    if((root2 == null && root2 != null) || (root2 != null && root2 == null) || (root2.val != root2.val)) {
        return false;
    }
    // é€’å½’è·å–å·¦å³å­æ ‘ä¿¡æ¯
    boolean left = isSameTree(root2.left, root2.left);
    boolean right = isSameTree(root2.right, root2.right);
    // å¿…é¡»å·¦å³å­æ ‘éƒ½æ˜¯trueæ‰ä¸ºtrue
    return left && right;
}
```

å†æ¥ä¸€ç§å†™æ³•ã€‚

```java
boolean isSame = true;
public boolean isSameTree(TreeNode root1, TreeNode root2) {
    dfs(root1, root2);
    return isSame;
}

private void dfs(TreeNode root1, TreeNode root2) {

    // Base case å¦‚æœä¸¤ä¸ªéƒ½ä¸ºç©ºè¿”å›true
    if(root1 == null && root2 == null) return;
    // å¦‚æœå…¶ä¸­ä¸€ä¸ªç»“ç‚¹ä¸ºç©ºæˆ–è€…ä¸¤ä¸ªçš„å€¼ä¸åŒï¼Œè¿”å›false
    if((root1 == null && root2 != null) || (root1 != null && root2 == null) || (root1.val != root2.val)) {
        isSame = false;
        return;
    }
    // é€’å½’è·å–å·¦å³å­æ ‘ä¿¡æ¯
    isSameTree(root1.left, root2.left);
    isSameTree(root1.right, root2.right);
}
```



### æœç´¢äºŒå‰æ ‘é—®é¢˜

æœç´¢äºŒå‰æ ‘åˆ©ç”¨å…¶**ç‰¹æ®Šçš„ç»“æ„**ï¼Œå¾€å¾€æœ‰ç‹¬ç‰¹çš„è§£æ³•ã€‚äºŒå‰æœç´¢æ ‘**é€’å½’æ—¶å¦‚æœæ¶‰åŠåˆ°æ¯”è¾ƒ**ï¼Œå¯ä»¥æ¯æ¬¡**ç›´æ¥ç æ‰ä¸€åŠä¸ç”¨é€’å½’**ã€‚

æœç´¢äºŒå‰æ ‘çš„**ä¸­åºéå†æ˜¯é€’å¢**çš„ï¼Œå¦‚æœä¾ç„¶æ˜¯ä¸­åºéå†çš„æ¨¡æ¿ï¼Œ**ä½†æ˜¯å…ˆéå†å³å­æ ‘ï¼Œå†å¤„ç†æ•°æ®ï¼Œå†éå†å·¦å­æ ‘å°±ä¼šæ˜¯é™åºã€‚**

#### 98.åˆ¤æ–­æ˜¯å¦æ˜¯äºŒå‰æœç´¢æ ‘ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/validate-binary-search-tree)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚ä¸€ä¸ªäºŒå‰æœç´¢æ ‘å…·æœ‰å¦‚ä¸‹ç‰¹å¾ï¼š

- èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å«å°äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
- èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å«å¤§äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
- æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚

##### 2. é¢˜è§£

###### (1) éé€’å½’ä¸­åºéå†æ³•

å¯¹äºæœç´¢äºŒå‰æ ‘ï¼Œå…¶**ä¸­åºéå†æ˜¯é€’å¢**çš„ï¼Œæ‰€ä»¥åˆ©ç”¨**éé€’å½’**çš„æ–¹å¼å¯ä»¥é€æ­¥æ£€éªŒã€‚æ•´ä½“æ˜¯**éé€’å½’ä¸­åºéå†çš„æ¨¡æ¿**ã€‚

```java
public boolean isBinarySearchTree(TreeNode head) {

    if(head == null) return true;
    // ç”¨äº†æ ˆæ¥å®ç°ä¸­åºéå†çš„éé€’å½’å®ç°
    Stack<TreeNode> stack = new Stack<>();
    // æ³¨æ„ï¼šç»´æŠ¤ä¸€ä¸ªå‰ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼
    int preValue = Integer.MIN_VALUE;
    while(!stack.empty() || head != null){
        if(head != null){
            // æŒç»­å°†å·¦èŠ‚ç‚¹å‹å…¥
            stack.push(head);
            head = head.left;
        }else{
            head = stack.pop();
            // æ³¨æ„ï¼šåˆ¤æ–­æ˜¯å¦æ˜¯å‡åº
            if(preValue > head.val) return false;
            // æ³¨æ„ï¼šåˆ‡æ¢å‰å€¼
            preValue = head.val;
            // å°†èŠ‚ç‚¹åˆ‡æ¢åˆ°å³å­ç»“ç‚¹
            head = head.right;
        }
    }
    return true;
}
```

###### (2) é€’å½’æ³•

**é€’å½’**åˆ¤æ–­ã€‚

```java
long preValue = Long.MIN_VALUE;
boolean isBST = true;
public boolean isValidBST(TreeNode root) {
    // Base case
    if (root == null) return true;
    dfs(root);
    return isBST;
}
// æ•´ä½“æ˜¯ä¸­åºéå†çš„æ¨¡æ¿
private void dfs(TreeNode root) {
    
    isValidBST(root.left);
    // ä¸æ»¡è¶³æ¡ä»¶
    if (root.val <= preValue) isBST = false;
    // æ›´æ–°å‰ä¸€ä¸ªå€¼
    preValue = root.val;
    // è®¿é—®å³å­æ ‘
    isValidBST(root.right);
}
```

#### 700.äºŒå‰æœç´¢æ ‘ä¸­æŸ¥æ‰¾ç»“ç‚¹ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

åœ¨ä¸€é¢—äºŒå‰æœç´¢æ ‘ä¸­**æ‰¾åˆ°ç»™å®šçš„ç›®æ ‡ç»“ç‚¹**ï¼Œæ‰¾ä¸åˆ°è¿”å› NULLã€‚

##### 2. é¢˜è§£

åˆ«çœ‹è¿™ä¸ªé¢˜ç®€å•å•Šï¼Œæœ‰çš„é¢è¯•å¯èƒ½ä¼šè€ƒå•Šã€‚

###### (1) é€’å½’æ³•

é€’å½’å®ç°éå¸¸ç®€å•ï¼š

- å¦‚æœæ ¹èŠ‚ç‚¹ä¸ºç©º root == null æˆ–è€…æ ¹èŠ‚ç‚¹çš„**å€¼ç­‰äºæœç´¢å€¼ val == root.val**ï¼Œè¿”å›æ ¹èŠ‚ç‚¹ã€‚

- å¦‚æœ val < root.valï¼Œè¿›å…¥æ ¹èŠ‚ç‚¹çš„**å·¦å­æ ‘æŸ¥æ‰¾** searchBST(root.left, val)ã€‚

- å¦‚æœ val > root.valï¼Œè¿›å…¥æ ¹èŠ‚ç‚¹çš„**å³å­æ ‘æŸ¥æ‰¾** searchBST(root.right, val)ã€‚

- è¿”å›**æ ¹èŠ‚ç‚¹**ã€‚

```java
public TreeNode searchBST(TreeNode root, int target) {
    // ä¸ºnullæˆ–è€…æ‰¾åˆ°å°±è¿”å›
    if (root == null || target == root.val) return root;

    // æ•´ä½“å‰åºéå†:æ ¹æ®å€¼å†³å®šå¾€å·¦è¿˜æ˜¯å³æŸ¥æ‰¾
    if(target < root.val) {
        return searchBST(root.left, target);
    } else {
        return searchBST(root.right, target);
    }
}
```

###### (2) è¿­ä»£æ³•

ä¸ºäº†**é™ä½ç©ºé—´å¤æ‚åº¦**ï¼Œå°†é€’å½’è½¬æ¢ä¸º**è¿­ä»£**ï¼Œæœ‰ç‚¹ç±»ä¼¼äºäºŒåˆ†çš„ä»£ç ï¼š

- å¦‚æœæ ¹èŠ‚ç‚¹ä¸ç©º root != null ä¸”æ ¹èŠ‚ç‚¹ä¸æ˜¯ç›®çš„èŠ‚ç‚¹ val != root.valï¼š

- å¦‚æœ val < root.valï¼Œè¿›å…¥æ ¹èŠ‚ç‚¹çš„**å·¦å­æ ‘æŸ¥æ‰¾** root = root.leftã€‚

- å¦‚æœ val > root.valï¼Œè¿›å…¥æ ¹èŠ‚ç‚¹çš„**å³å­æ ‘æŸ¥æ‰¾** root = root.rightã€‚

- è¿”å› rootã€‚

```java
public TreeNode searchBST2(TreeNode root, int target) {
    while (root != null) {
        if(root.val == target) {
            return root;
            // å¾€å³å¯»æ‰¾
        } else if (root.val < target) {
            root = root.right;
        } else {
            root = root.left;
        }
    }
    return null;
}
```

ä¸‹é¢çš„æ’å…¥ç»“ç‚¹çš„è¿‡ç¨‹å…¶å®å°±æ˜¯æœç´¢çš„è¿‡ç¨‹ï¼Œä¸è¿™ä¸ªé¢˜ç±»ä¼¼ã€‚

#### 701.äºŒå‰æœç´¢æ ‘æ’å…¥ç»“ç‚¹ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree)

ç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„**æ ¹èŠ‚ç‚¹**å’Œè¦æ’å…¥æ ‘ä¸­çš„**å€¼**ï¼Œå°†**å€¼æ’å…¥äºŒå‰æœç´¢æ ‘**ã€‚ è¿”å›æ’å…¥åäºŒå‰æœç´¢æ ‘çš„**æ ¹èŠ‚ç‚¹**ã€‚ ä¿è¯åŸå§‹äºŒå‰æœç´¢æ ‘ä¸­**ä¸å­˜åœ¨æ–°å€¼**ã€‚æ³¨æ„ï¼Œå¯èƒ½å­˜åœ¨å¤šç§æœ‰æ•ˆçš„æ’å…¥æ–¹å¼ï¼Œåªè¦æ ‘åœ¨æ’å…¥åä»ä¿æŒä¸ºäºŒå‰æœç´¢æ ‘å³å¯ã€‚ ä½ å¯ä»¥è¿”å›ä»»æ„æœ‰æ•ˆçš„ç»“æœã€‚ä¾‹å¦‚,ï¼Œç»™å®šäºŒå‰æœç´¢æ ‘å’Œ æ’å…¥çš„å€¼ 5ã€‚

        4
       / \
      2   7
     / \
    1   3

##### 2. é¢˜è§£

äºŒå‰æœç´¢æ ‘çš„å·¨å¤§ä¼˜åŠ¿å°±æ˜¯ï¼šåœ¨å¹³å‡æƒ…å†µä¸‹ï¼Œèƒ½å¤Ÿåœ¨ **O(logN) çš„æ—¶é—´å†…å®Œæˆæœç´¢å’Œæ’å…¥å…ƒç´ **ã€‚äºŒå‰æœç´¢æ ‘çš„æ’å…¥æ–¹æ³•éå¸¸ç®€å•ï¼Œå°†**æ’å…¥çš„èŠ‚ç‚¹ä½œä¸ºå¶å­èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ’å…¥**ã€‚æ’å…¥åˆ°**å“ªä¸ªå¶èŠ‚ç‚¹**å¯ä»¥éµå¾ªä»¥ä¸‹åŸåˆ™ï¼š

- è‹¥ val > node.valï¼Œæ’å…¥åˆ°**å³**å­æ ‘ã€‚
- è‹¥ val < node.valï¼Œæ’å…¥åˆ°**å·¦**å­æ ‘ã€‚

###### (1) é€’å½’æ–¹å¼

ç®—æ³•ï¼š

- è‹¥ val > root.valï¼Œæ’å…¥åˆ°**å³å­æ ‘**ã€‚
- è‹¥ val < root.valï¼Œæ’å…¥åˆ°**å·¦å­æ ‘**ã€‚
- **ç›´åˆ°** root == nullï¼Œåˆ™å¯ä»¥**æ’å…¥å…ƒç´ **ï¼Œå¹¶è¿”å› **TreeNode**(val)ã€‚
- è¿”å› rootã€‚

```java
public TreeNode insertIntoBST(TreeNode root, int val) {
    // å¦‚æœæ ¹ç»“ç‚¹ä¸ºnullç›´æ¥è¿”å›è¿™ä¸ªå€¼çš„èŠ‚ç‚¹
    if (root == null) return new TreeNode(val);
    // æ’å…¥å·¦å­æ ‘
    if (val > root.val) {
        root.right = insertIntoBST(root.right, val);
        // æ’å…¥å³å­æ ‘
    } else {
        root.left = insertIntoBST(root.left, val);
    }
    // è¿”å›æ ¹ç»“ç‚¹
    return root;
}
```

######  (2) è¿­ä»£æ³•

ä¸Šé¢çš„é€’å½’å¯ä»¥è½¬æ¢æˆ**è¿­ä»£**çš„è§£å†³æ–¹æ¡ˆã€‚ä¹Ÿå°±æ˜¯**ä¸æ–­æ ¹æ®ç»“ç‚¹å€¼å¾€å·¦è¾¹æˆ–è€…å³è¾¹æ‰¾æ’å…¥ç‚¹**ã€‚

```java
public TreeNode insertIntoBST2(TreeNode root, int val) {
    // Base case
    if (root == null) return new TreeNode(val);
    TreeNode cur = root;
    // éå†æ‰¾åˆ°æ’å…¥ä½ç½®
    while (true) {
        // å°äºå¾€å·¦è¾¹æ’å…¥
        if (val < cur.val) {
            if (cur.left != null) {
                cur = cur.left;
            } else {
                cur.left = new TreeNode(val);
                break;
            }
        } else if (val > cur.val) {
            if (cur.right != null) {
                cur = cur.right;
            } else {
                cur.right = new TreeNode(val);
                break;
            }
        }
    }
    return root;
}
```

#### 938.äºŒå‰æœç´¢æ ‘çš„èŒƒå›´å’Œã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/range-sum-of-bst/)

ç»™å®šäºŒå‰æœç´¢æ ‘çš„æ ¹ç»“ç‚¹ `root`ï¼Œè¿”å› `L` å’Œ `R`ï¼ˆå«ï¼‰ä¹‹é—´çš„**æ‰€æœ‰ç»“ç‚¹çš„å€¼çš„å’Œ**ã€‚äºŒå‰æœç´¢æ ‘ä¿è¯å…·æœ‰å”¯ä¸€çš„å€¼ã€‚

```
è¾“å…¥ï¼šroot = [10,5,15,3,7,null,18], L = 7, R = 15
è¾“å‡ºï¼š32
```

##### 2. é¢˜è§£

è¿™ä¸ªé¢˜å°±æ˜¯åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§ï¼Œ**ä¸ç”¨æ¯ä¸ªèŠ‚ç‚¹éƒ½å»éå†çš„**ã€‚åœ¨ä»£ç ä¸­ç”¨**é€’å½’å’Œè¿­ä»£**çš„æ–¹æ³•åˆ†åˆ«å®ç°äº†**æ·±åº¦ä¼˜å…ˆæœç´¢**ã€‚

###### (1) é€’å½’æ³•DFS

å¯¹æ ‘è¿›è¡Œ**æ·±åº¦ä¼˜å…ˆæœç´¢**ï¼Œå¯¹äº**å½“å‰èŠ‚ç‚¹ node**ï¼Œå¦‚æœ node.val **å°äºç­‰äº L**ï¼Œé‚£ä¹ˆ**åªéœ€è¦ç»§ç»­æœç´¢å®ƒçš„å³å­æ ‘**ï¼›å¦‚æœ **node.val å¤§äºç­‰äº R**ï¼Œé‚£ä¹ˆåªéœ€è¦ç»§ç»­æœç´¢å®ƒçš„**å·¦å­æ ‘**ï¼›å¦‚æœ **node.val åœ¨åŒºé—´ (L,  R)** ä¸­ï¼Œåˆ™éœ€è¦æœç´¢å®ƒçš„**æ‰€æœ‰å­æ ‘**ã€‚è¿™ä¸ªæ–¹æ³•å¯ä»¥ã€‚

```java
int sum;
public int rangeSumBST(TreeNode root, int L, int R) {
    sum = 0;
    dfs(root, L, R);
    return sum;
}

// é€’å½’æ±‚è§£ï¼Œæ•´ä½“å…ˆåºéå†æ¨¡æ¿
public void dfs(TreeNode node, int left, int right) {
    if (node != null) {
        // è¿™ä¸ªå€¼OKï¼ŒåŠ ä¸Š
        if (left <= node.val && node.val <= right)
            sum = sum + node.val;
        // é€’å½’å·¦å­æ ‘
        if (left < node.val) dfs(node.left, left, right);
        // é€’å½’å³å­æ ‘
        if (node.val < right) dfs(node.right, left, right);
    }
}
```

###### (2) è¿­ä»£DFS

ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸­åºéå†çš„**è¿­ä»£**çš„æ–¹å¼å®ç°ä¸Šè¿°çš„ DFSã€‚æ— éå°±æ˜¯è¿›è¡Œäº†**ä¸€æ¬¡éå†**ã€‚ä¸‹é¢çš„æ–¹æ³•æ—¶é—´ç©ºé—´éƒ½ä¸å¤ªå¥½ã€‚

```java
public int rangeSumBST2(TreeNode root, int leftVal, int rightVal) {
    int sum = 0;
    // ä½¿ç”¨æ ˆ
    Stack<TreeNode> stack = new Stack();
    // æ ¹èŠ‚ç‚¹å‹æ ˆ
    stack.push(root);
    while (!stack.isEmpty()) {
        // å¼¹å‡ºä¸€ä¸ªèŠ‚ç‚¹
        TreeNode node = stack.pop();
        if (node != null) {
            // ç¬¦åˆæ¡ä»¶
            if (leftVal <= node.val && node.val <= rightVal)
                sum = sum + node.val;
            // å…ˆå‹å·¦è¾¹å†å‹å³è¾¹
            if (leftVal < node.val) stack.push(node.left);
            if (node.val < rightVal) stack.push(node.right);
        }
    }
    return sum;
}
```

#### 1305.ä¸¤æ£µäºŒå‰æœç´¢æ ‘å€¼çš„åˆå¹¶ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/)

ç»™ä½  `root1` å’Œ `root2` è¿™ä¸¤æ£µäºŒå‰æœç´¢æ ‘ã€‚è¯·ä½ è¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å« **ä¸¤æ£µæ ‘** ä¸­çš„**æ‰€æœ‰æ•´æ•°**å¹¶æŒ‰ **å‡åº** æ’åºã€‚

<img src="assets/image-20200503201430642.png" alt="image-20200503201430642" style="zoom:67%;" />

```java
è¾“å…¥ï¼šroot1 = [2,1,4], root2 = [1,0,3]
è¾“å‡ºï¼š[0,1,1,2,3,4]
```

##### 2. é¢˜è§£

###### (1) æš´åŠ›æ³•

**éå† + æ’åº**æ–¹æ³•ã€‚å¯¹ä¸¤æ£µæ ‘è¿›è¡Œä»»æ„**å½¢å¼çš„éå†**ï¼ˆæ·±åº¦ä¼˜å…ˆæœç´¢ã€å¹¿åº¦ä¼˜å…ˆæœç´¢ã€å‰åºéå†ã€ä¸­åºéå†ã€ååºéå†ï¼‰ï¼Œå¹¶å°†éå†åˆ°çš„æ‰€æœ‰å…ƒç´ æ”¾å…¥ä¸€ä¸ª**æ•°ç»„**ä¸­ï¼Œæœ€åå¯¹è¿™ä¸ªæ•°ç»„è¿›è¡Œ**æ’åº**å³å¯ã€‚

###### (2) éå†+æœ‰åºé“¾è¡¨æ’åº

æ–¹æ³•ä¸€ä¸­å¹¶æ²¡æœ‰ç”¨åˆ°**äºŒå‰æœç´¢æ ‘æœ¬èº«**çš„æ€§è´¨ã€‚å¦‚æœå¯¹äºŒå‰æœç´¢æ ‘è¿›è¡Œ**ä¸­åºéå†**ï¼Œå°±å¯ä»¥ç›´æ¥å¾—åˆ°æ ‘ä¸­æ‰€æœ‰å…ƒç´ **å‡åºæ’åºå**çš„ç»“æœã€‚å› æ­¤å¯ä»¥å¯¹ä¸¤æ£µæ ‘**åˆ†åˆ«è¿›è¡Œä¸­åºéå†**ï¼Œå¾—åˆ°æ•°ç»„ v1 å’Œ v2ï¼Œå®ƒä»¬åˆ†åˆ«å­˜æ”¾äº†ä¸¤æ£µæ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œä¸”å‡å·²æœ‰åºã€‚åœ¨è¿™ä¹‹åï¼Œå¾—åˆ°çš„ä¸¤ä¸ªç»“æœé“¾è¡¨å°±æ˜¯æœ‰åºçš„ï¼Œé€šè¿‡**å½’å¹¶æ’åºçš„æ–¹æ³•å¯¹ v1 å’Œ v2 è¿›è¡Œæ’åº**ï¼Œå°±å¯ä»¥å¾—åˆ°æœ€ç»ˆçš„ç»“æœã€‚

å…³é”®ç‚¹æ˜¯**åˆå¹¶**ä¸¤ä¸ªæœ‰åºçš„é“¾è¡¨ã€‚

```java
public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
    List<Integer> ansList1 = new ArrayList<>();
    List<Integer> ansList2 = new ArrayList<>();
    // é‡‡ç”¨ä¸­åºéå†æ–¹å¼å°†å€¼åˆ†åˆ«æ”¾å…¥åˆ—è¡¨
    dfs(root1, ansList1);
    dfs(root2, ansList2);
    // å½’å¹¶æ’åºåˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
    return merge(ansList1, ansList2);
}
// ä¸­åºéå†
private void dfs(TreeNode root, List<Integer> ansList) {
    if (root == null) return;
    // ä¸­åºéå†æ”¾å…¥å€¼
    dfs(root.left, ansList);
    ansList.add(root.val);
    dfs(root.right, ansList);
}
// å½’å¹¶æ’åºä¸¤ä¸ªæœ‰åºé“¾è¡¨
private List<Integer> merge(List<Integer> list1, List<Integer> list2) {
    List<Integer> ansList = new ArrayList<>();
    int size1 = list1.size();
    int size2 = list2.size();
    int index1, index2;
    for (index1 = 0, index2 = 0; index1 < size1 && index2 < size2;) {
        int num1 = list1.get(index1);
        int num2 = list2.get(index2);
        if (num1 < num2) {
            ansList.add(num1);
            index1++;
        } else {
            ansList.add(num2);
            index2++;
        }
    }
    while (index1 < size1) {
        ansList.add(list1.get(index1++));
    }
    while (index2 < size2) {
        ansList.add(list2.get(index2++));
    }
    return ansList;
}
```

æ—¶é—´å¤æ‚åº¦ï¼šO(n) ä¸¤æ¬¡çš„ä¸­åºéå†å’Œä¸€æ¬¡çš„å½’å¹¶æ“ä½œéƒ½æ˜¯ O(n) çš„æ—¶é—´å¤æ‚åº¦ã€‚ç©ºé—´å¤æ‚åº¦ï¼šO(n)ã€‚

###### (3) **éå†+ä¼˜å…ˆé˜Ÿåˆ—**

åœ¨æ ‘éå†çš„æ—¶å€™ç”¨ä¸€ä¸ª**ä¼˜å…ˆé˜Ÿåˆ—**ï¼ˆé»˜è®¤**å°æ ¹å †**ï¼‰æ¥**æ·»åŠ å…ƒç´ **ï¼›ç„¶åå°†ä¼˜å…ˆé˜Ÿåˆ—çš„å…ƒç´ **é€ä¸ªå–å‡ºåˆ° list** ä¸­å³å¯ã€‚

````java
// ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—
private PriorityQueue<Integer> priorityQueue;

public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
    priorityQueue = new PriorityQueue<>();
    // ä¸¤ä¸ªæ ‘çš„å€¼åˆ†åˆ«æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—
    dfs(root1);
    dfs(root2);
    List<Integer> ansList = new ArrayList<>();
    // å–å€¼æ”¾å…¥ç»“æœåˆ—è¡¨
    while (!priorityQueue.isEmpty()) {
        ansList.add(priorityQueue.poll());
    }
    return ansList;
}

private void dfs(TreeNode root) {
    if (root == null) return;
    priorityQueue.offer(root.val);
    dfs(root.left);
    dfs(root.right);
}
````

---

#### 501.äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

ç»™å®šä¸€ä¸ª**æœ‰ç›¸åŒå€¼**çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼Œæ‰¾å‡º BST ä¸­çš„**æ‰€æœ‰ä¼—æ•°**ï¼ˆå‡ºç°**é¢‘ç‡æœ€é«˜**çš„å…ƒç´ ï¼‰ã€‚ä¾‹å¦‚ï¼šç»™å®š BST [1, null, 2, 2]ï¼Œè¿”å› [2]ã€‚

```
   1
    \
     2
    /
   2
```

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•(ä¸­åºéå†)

äºŒå‰æœç´¢æ ‘çš„**å·¦å³å­ç»“ç‚¹å’Œçˆ¶ç»“ç‚¹**ä¹‹é—´æœ‰å¤§å°å…³ç³»çš„é™åˆ¶ï¼Œä¸”äºŒå‰æ ‘çš„**ä¸­åºéå†æ˜¯å‡åº**çš„ã€‚ç”±æ­¤ï¼Œé—®é¢˜å¯ä»¥è½¬å˜æˆåœ¨**ä¸€ç»„å‡åºæ’åˆ—çš„æ•°ä¸­æŸ¥æ‰¾ä¼—æ•°**ã€‚

æ—¢ç„¶æ•°å­—æ˜¯**å‡åº**çš„ï¼Œå°±å¯ä»¥**éå†ä¸€æ¬¡**å®Œæˆç»Ÿè®¡ã€‚ä»å°åˆ°å¤§éå†æ•°æ®æ‰¾åˆ°**æ¬¡æ•°æœ€å¤§**çš„å³å¯ã€‚

```java
// æœ€å¤§çš„å€¼ä¸ªæ•°
int maxNumber = 0;
List<Integer> resList = new LinkedList<>();
// å½“å‰å€¼
int currentValue;
// å½“å‰å€¼è®¡æ•°å™¨
int counter;

public int[] findMode(TreeNode root) {
    // Base case
    if (root == null) return new int[0];
    // åˆå§‹åŒ–å½“å‰å€¼
    currentValue = root.val;
    counter = 0;
    // è¿›è¡Œä¸­åºéå†é€’å½’
    helper(root);
    // åˆ—è¡¨é‡Œé¢å­˜çš„å°±æ˜¯ä¼—æ•°åˆ—è¡¨
    int[] result = new int[resList.size()];
    for (int i = 0; i < resList.size(); i++) {
        result[i] = resList.get(i);
    }
    return result;
}

// ä¸­åºéå†é€’å½’:æ•´ä½“æ˜¯ä¸­åºé€’å½’çš„æ¶æ„
public void helper(TreeNode root) {
    // Base case
    if (root == null) return;
    helper(root.left);
    // å½“å‰å€¼ä¸ç»“ç‚¹å€¼ç›¸åŒåˆ™å½“å‰å€¼è®¡æ•°å™¨+1
    if (currentValue == root.val) {
        counter++;
        // å¦åˆ™è®¡æ•°å™¨å›é‡ç½®ä¸º1å¹¶å½“å‰å€¼æ›´æ–°ä¸ºç»“ç‚¹å€¼
    } else if (currentValue != root.val) {
        counter = 1;
        currentValue = root.val;
    }
    // å¦‚æœå½“å‰çš„è®¡æ•°å™¨å€¼ç­‰äºæœ€å¤§å€¼å°†è¿™ä¸ªæ•°è®°å½•åˆ°åˆ—è¡¨ä¸­
    if (counter == maxNumber) {
        resList.add(currentValue);
        // è¯´æ˜è¿˜æœ‰æ•°é‡æ›´å¤šçš„ä¼—æ•°
    } else if (counter > maxNumber) {
        // æ›´æ–°æœ€å¤§å€¼ä¸ªæ•°
        maxNumber = counter;
        // æ¸…ç©ºä¹‹å‰ç¼“å­˜çš„ä¼—æ•°è®°å½•
        resList.clear();
        resList.add(currentValue);
    }

    helper(root.right);
}
```

---

#### 235.æœç´¢äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree)

ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼Œæ‰¾åˆ°è¯¥æ ‘ä¸­**ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ**ã€‚ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªç»“ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªç»“ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€ä¾‹å¦‚ï¼Œç»™å®šå¦‚ä¸‹äºŒå‰æœç´¢æ ‘:  root = [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5]ã€‚

![image-20200505210928389](assets/image-20200505210928389.png)

```
è¾“å…¥: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
è¾“å‡º: 6  è§£é‡Š: èŠ‚ç‚¹2å’ŒèŠ‚ç‚¹8çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯6
```

##### 2. é¢˜è§£

**å¯¹äºæœç´¢äºŒå‰æ ‘æ¥è¯´ï¼Œæœ€è¿‘å…¬å…±ç»“ç‚¹æ˜¯å°äºç­‰äºä¸¤ä¸ªç»“ç‚¹çš„è¾ƒå¤§å€¼ï¼Œå¤§äºç­‰äºä¸¤ä¸ªç»“ç‚¹çš„è¾ƒå°å€¼**ã€‚

###### (1) å±‚åºè¿­ä»£æ³•BFS

ç›´æ¥ä½¿ç”¨**å±‚åºéå†**çš„æ–¹å¼ï¼Œç”±äºæœç´¢äºŒå‰æ ‘çš„ç‰¹æ€§ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„ç»“ç‚¹å³å¯ã€‚æ•´ä½“å°±æ˜¯**å±‚åºéå†**çš„æ¨¡æ¿ã€‚

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode node1, TreeNode node2) {
    // Base case
    if(root == null) return null;
    // å¾—åˆ°ä¸¤ä¸ªç›®æ ‡ç»“ç‚¹çš„è¾ƒå¤§å€¼å’Œè¾ƒå°å€¼
    int min = Math.min(node1.val, node2.val);
    int max = Math.max(node1.val, node2.val);
    // ä½¿ç”¨æ™®é€šå±‚åºéå†çš„æ–¹å¼è¿›è¡Œ
    Queue<TreeNode> queue = new LinkedList();
    queue.add(root);
    while(!queue.isEmpty()) {
        TreeNode node = queue.poll();
        // åˆ¤æ–­å€¼ï¼Œç¬¬ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å°±ç›´æ¥è¿”å›
        if(node.val >= min && node.val <= max) return node;
        if(node.left != null) queue.offer(node.left);
        if(node.right != null) queue.offer(node.right);
    }
    // æ²¡æ‰¾åˆ°è¿”å›null
    return null;
}
```

###### (2) é€’å½’æ³•

ä¾ç„¶æ˜¯åˆ©ç”¨æœç´¢äºŒå‰æ ‘çš„ç‰¹æ€§ï¼Œ**å¦‚æœ p å’Œ q åœ¨ root çš„ä¸¤è¾¹ï¼Œé‚£ä¹ˆ root å°±æ˜¯ p å’Œ q çš„æœ€ä½çš„å…¬å…±ç¥–å…ˆ**ï¼Œè¿™ç§æƒ…å†µåŒ…å«ä¸‰ç§å…·ä½“çš„æƒ…å†µï¼š

- **p å’Œ q åœ¨ root çš„ä¸¤è¾¹**ï¼›
- p å°±æ˜¯ rootï¼Œq åœ¨ root çš„å“ªè¾¹**æ— æ‰€è°“**ï¼›
- q å°±æ˜¯ rootï¼Œp åœ¨ root çš„å“ªè¾¹**æ— æ‰€è°“**ï¼›

å¦‚æœä¸æ˜¯ä¸Šé¢çš„æƒ…å†µï¼Œp å’Œ q è¦ä¹ˆ**å…¨åœ¨** root çš„å·¦è¾¹ï¼Œè¦ä¹ˆ**å…¨åœ¨** root çš„å³è¾¹ï¼Œè¿™æ—¶åªéœ€é€’å½’çš„å» root çš„å·¦å­æ ‘æˆ–å³å­æ ‘ä¸­æ‰¾ p å’Œ q çš„æœ€ä½å…¬å…±ç¥–å…ˆã€‚

ç”±äºæ˜¯æ‰¾æœ€å°çš„å…¬å…±ç¥–å…ˆï¼Œæ‰€ä»¥**æ•´ä½“æ˜¯ååºéå†çš„æ¨¡æ¿**ã€‚

```java
public TreeNode LowestCommonAncestor(TreeNode root, TreeNode node1, TreeNode node2) {
    // Base case
    if (node1 == null || node2 == null || root == null) return null;
    // ä¸¤ä¸ªç»“ç‚¹éƒ½åœ¨å½“å‰èŠ‚ç‚¹å·¦å­æ ‘åˆ™ä»¥å½“å‰èŠ‚ç‚¹å·¦å­èŠ‚ç‚¹ç»§ç»­éå†
    if (node1.val < root.val && node2.val < root.val) {
        return LowestCommonAncestor(root.left, node1, node2);
    }
    // ä¸¤ä¸ªç»“ç‚¹éƒ½åœ¨å½“å‰èŠ‚ç‚¹å³å­æ ‘åˆ™ä»¥å½“å‰èŠ‚ç‚¹å³å­èŠ‚ç‚¹ç»§ç»­éå†
    if (node1.val > root.val && node2.val > root.val) {
        return LowestCommonAncestor(root.right, node1, node2);
    }
    // å¦‚æœå·¦è¾¹å¤§äºç­‰äºï¼Œå³è¾¹å°äºç­‰äºï¼Œæ‰¾åˆ°äº†æ»¡è¶³æ¡ä»¶çš„ç›´æ¥è¿”å›root
    if (node1.val <= root.val && node2.val >= root.val) {
        return root;
    }
    return root;
}
```

è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªæ‰¾ä¸¤ä¸ª**æ™®é€š**äºŒå‰æ ‘ç»“ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆé—®é¢˜ï¼Œ**è§åé¢**ã€‚

----

#### 783.äºŒå‰æœç´¢æ ‘ç»“ç‚¹æœ€å°è·ç¦»é—®é¢˜ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes)

ç»™å®šä¸€ä¸ª**äºŒå‰æœç´¢æ ‘**çš„æ ¹èŠ‚ç‚¹ rootï¼Œè¿”å›æ ‘ä¸­**ä»»æ„ä¸¤èŠ‚ç‚¹**çš„å·®çš„æœ€å°å€¼ã€‚

```java
è¾“å…¥: root = [4, 2, 6, 1, 3, null, null]
è¾“å‡º: 1
```

ç»™å®šçš„æ ‘ [4, 2, 6, 1, 3, null, null] å¯è¡¨ç¤ºä¸ºä¸‹å›¾:

          4
        /   \
      2      6
     / \    
    1   3  

æœ€å°çš„å·®å€¼æ˜¯ 1, å®ƒæ˜¯èŠ‚ç‚¹ 1 å’ŒèŠ‚ç‚¹ 2 çš„å·®å€¼, ä¹Ÿæ˜¯èŠ‚ç‚¹ 3 å’ŒèŠ‚ç‚¹ 2 çš„å·®å€¼ã€‚

è¿˜æœ‰ä¸€ä¸ªé¢˜æ˜¯æ±‚**ä»»æ„ä¸¤ç»“ç‚¹çš„ç»å¯¹å€¼ä¹‹å·®çš„æœ€å°å€¼**ï¼Œå…¶å®æ˜¯ä¸€æ ·çš„ã€‚è¿æ¥ï¼šhttps://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/submissions/

##### 2. é¢˜è§£

è¿™ä¸ªé¢˜å…¶å®å°±æ˜¯è€ƒå¯ŸäºŒå‰æœç´¢æ ‘çš„**ä¸­åºéå†**æ˜¯é€’å¢çš„æ€§è´¨ï¼Œæœ€å°çš„**è·ç¦»è‚¯å®šäº§ç”Ÿä¸ä¸¤ä¸ªç›¸é‚»çš„ç»“ç‚¹ä¹‹é—´**ã€‚ä¸­åºéå†å¯ä»¥é€šè¿‡é€’å½’æˆ–è€…è¿­ä»£è¿›è¡Œã€‚

###### (1) é€’å½’ä¸­åºéå†æ³•

åªéœ€è¦**è®°å½•å‰ä¸€ä¸ªç»“ç‚¹**ï¼Œç„¶åå¯¹æ¯”å‰ä¸€ä¸ªå’Œå½“å‰èŠ‚ç‚¹çš„å€¼å³å¯ã€‚æ•´ä½“æ˜¯**ä¸­åºéå†æ¶æ„**ï¼Œä¸­åºéå†å¯ç”¨é€’å½’æˆ–è€…è¿­ä»£å®ç°ã€‚

```java
// è®°å½•ç»“æœ
int res = Integer.MAX_VALUE;
// è®°å½•ä¸Šä¸€ä¸ªç»“ç‚¹
TreeNode lastNode = null;

public int minDiffInBST(TreeNode root) {
    process(root);
    return res;
}

// ä¸­åºéå†äºŒå‰æœç´¢æ ‘
private void process(TreeNode root) {
    // Base case
    if(root == null) return;
    process(root.left);
    // å¦‚æœä¸Šä¸€ä¸ªç»“ç‚¹ä¸ä¸ºç©ºåˆ™è®¡ç®—æ›´æ–°æœ€å°å€¼
    if(lastNode != null) {
        res = Math.min(res, root.val - lastNode.val);
    }
    // æ›´æ–°ä¸Šä¸€ä¸ªç»“ç‚¹çš„æŒ‡é’ˆä¸ºå½“å‰èŠ‚ç‚¹
    lastNode = root;
    process(root.right);
}
```

###### (2) è¿­ä»£ä¸­åºéå†æ–¹æ³•

ä¿®æ”¹æˆ**è¿­ä»£æ–¹å¼**è¿›è¡Œï¼Œæ•´ä½“å°±æ˜¯è¿­ä»£ä¸­åºéå†çš„æ–¹å¼ã€‚

```java
public int midOrderUnRecursive(TreeNode root) {

    // æ³¨æ„ï¼šè®°å½•å‰ä¸€ä¸ªç»“ç‚¹
    TreeNode lastNode = null;
    int res = Integer.MAX_VALUE;

    if (root != null) {
        // å‡†å¤‡ä¸€ä¸ªæ ˆ
        Stack<TreeNode> stack = new Stack<>();
        // ä¸æŠŠå¤´ç»“ç‚¹å‹æ ˆ
        while (!stack.isEmpty() || root != null) {
            // æŒç»­å°†å½“å‰ç»“ç‚¹çš„å·¦å­èŠ‚ç‚¹å‹æ ˆ
            if (root != null) {
                stack.push(root);
                root = root.left;
            } else {
                // å¼¹å‡ºæ•°æ®å¤„ç†
                root = stack.pop();
                // æ³¨æ„ï¼šå¤„ç†æ•°æ®
                if(lastNode != null) {
                    res = Math.min(res, root.val - lastNode.val);
                }
                lastNode = root;
                // å˜åˆ°å³å­æ ‘
                root = root.right;
            }
        }
    }
    return res;
}
```

-----

#### 669.ä¿®å‰ªäºŒå‰æœç´¢æ ‘ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/trim-a-binary-search-tree)

ç»™å®šä¸€ä¸ª**äºŒå‰æœç´¢æ ‘**ï¼ŒåŒæ—¶ç»™å®š**æœ€å°è¾¹ç•Œ L å’Œæœ€å¤§è¾¹ç•Œ R**ã€‚é€šè¿‡**ä¿®å‰ª**äºŒå‰æœç´¢æ ‘ï¼Œä½¿å¾—**æ‰€æœ‰èŠ‚ç‚¹çš„å€¼åœ¨ [L, R]** ä¸­ (R >= L) ã€‚ä½ å¯èƒ½éœ€è¦**æ”¹å˜æ ‘çš„æ ¹èŠ‚ç‚¹**ï¼Œæ‰€ä»¥ç»“æœåº”å½“è¿”å›ä¿®å‰ªå¥½çš„äºŒå‰æœç´¢æ ‘çš„**æ–°çš„æ ¹èŠ‚ç‚¹**ã€‚

```java
è¾“å…¥: 
    1
   / \
  0   2

  L = 1
  R = 2

è¾“å‡º: 
    1
      \
       2
```

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

ä¿®å‰ªä¸€æ£µæ ‘ï¼Œå¦‚æœæ ¹ç»“ç‚¹çš„å€¼å°äºç»™å®šçš„å·¦è¾¹ç•Œ Lï¼Œé‚£ä¹ˆå½“å‰ç»“ç‚¹åŠå…¶**å·¦å­æ ‘**å°±ä¼šè¢«ä¿®**å‰ªæ‰**ï¼Œä¿®**å‰ªåçš„æ ‘**åº”è¯¥æ˜¯å…¶**å³å­æ ‘**ï¼Œä½†æ˜¯å³å­æ ‘ä¸ä¸€å®šæ˜¯ç¬¦åˆèŒƒå›´çš„æ ‘ï¼Œæ‰€ä»¥è¦å¯¹å…¶**å³å­æ ‘è¿›è¡Œé€’å½’ä¿®å‰ª**ï¼Œç„¶åè¿”å›ä¿®å‰ªåçš„å³å­æ ‘ã€‚åŒç†ï¼Œæ ¹ç»“ç‚¹çš„å€¼å¤§äºç»™å®šçš„å³è¾¹ç•Œ  Rï¼Œä¿®å‰ªåçš„æ ‘åº”è¯¥æ˜¯å…¶å·¦å­æ ‘ä¸”è¦å¯¹å·¦å­æ ‘ä¿®å‰ªã€‚æ¶‰åŠåˆ°æ”¹å˜æ ‘çš„ç»“æ„ï¼Œå°±éœ€è¦æ›´æ–°é“¾æ¥ï¼Œå¦‚æœå½“å‰ç»“ç‚¹å€¼åœ¨èŒƒå›´å†…ï¼Œé‚£ä¹ˆä¿®å»ºå…¶å·¦å³å­æ ‘ï¼Œå¹¶ä¸”æ›´æ–°å·¦å³é“¾æ¥ã€‚æœ€åå°†å½“å‰ä¿®å‰ªå¥½çš„å­æ ‘è¿”å›ã€‚
æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œ ç©ºé—´å¤æ‚åº¦ä¸æ ‘é«˜æˆæ­£æ¯”ã€‚

è‡ªåº•å‘ä¸Šçš„ä¿®å‰ªæ‰€ä»¥æ•´ä½“æ˜¯**ååºéå†**æ¶æ„ã€‚

```java
public TreeNode trimBST(TreeNode root, int left, int right) {
    // Base case
    if(root == null) return null;
    if(root.val < left) return trimBST(root.right, left, right);
    if(root.val > right) return trimBST(root.left, left, right);
    // æ¶‰åŠåˆ°æ”¹å˜æ ‘ç»“æ„çš„ï¼Œè‚¯å®šè¦æ”¹å˜é“¾æ¥
    root.left = trimBST(root.left, left, right);
    // é€šè¿‡è¿™ä¸¤ä¸ªé“¾æ¥æ›´æ–°ï¼Œå½“å‰ç»“ç‚¹çš„å·¦å³å­æ ‘éƒ½æ˜¯ä¿®å‰ªè¿‡çš„äº†
    root.right = trimBST(root.right, left, right);
    // è¿”å›ä¿®æ”¹è¿‡åçš„rootç»“ç‚¹
    return root;
}
```

#### ğŸ’¯538.æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/convert-bst-to-greater-tree)

ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼‰ï¼ŒæŠŠå®ƒè½¬æ¢æˆä¸º**ç´¯åŠ æ ‘**ï¼ˆGreater Tree)ï¼Œä½¿å¾—æ¯ä¸ªèŠ‚ç‚¹çš„å€¼æ˜¯**åŸæ¥çš„èŠ‚ç‚¹å€¼åŠ ä¸Šæ‰€æœ‰å¤§äºå®ƒçš„èŠ‚ç‚¹å€¼ä¹‹å’Œ**ã€‚ä¾‹å¦‚ï¼šè¾“å…¥åŸå§‹äºŒå‰æœç´¢æ ‘ï¼š

```java
	  5
    /   \
   2     13
```

è¾“å‡ºè½¬æ¢ä¸ºç´¯åŠ æ ‘ã€‚

```java
      18
    /   \
  20     13
```

##### 2. é¢˜è§£

ä¸»è¦æ˜¯é æ€è€ƒï¼**äºŒå‰æœç´¢æ ‘**çš„ä¸­åºéå†å°±æ˜¯æŒ‰ç…§**å‡åºæ’åˆ—**çš„ã€‚é‚£å¦‚æœ**å…ˆéå†å³å­æ ‘åˆ™å°±æ˜¯é™åºæ’åˆ—**çš„ï¼

è¿™ä¸ªé¢˜çš„æ€è·¯æ˜¯**å…ˆå¤„ç†æœ€å¤§çš„æ•°æ®**ï¼Œ**æœ€å¤§çš„å°±æ˜¯å…¶æœ¬èº«**ï¼Œæ‰€ä»¥ä¸å˜ï¼Œåç»­çš„ç»“ç‚¹éƒ½æ˜¯**å½“å‰çš„ç»“ç‚¹+åé¢çš„æ¯”å®ƒå¤§çš„æ‰€æœ‰ç»“ç‚¹ä¹‹å’Œ**ï¼Œæ‰€ä»¥ç»´æŠ¤ä¸€ä¸ª **sum å˜é‡**ï¼Œç”¨äºè®°å½•å·²ç»æ±‚**çš„å’Œ**ã€‚

æ³¨æ„ï¼šæ•´ä¸ªä»£ç æ˜¯å±äº**ä¸­åºéå†**çš„æ¡†æ¶ï¼Œä½†æ˜¯æ˜¯**==å…ˆé€’å½’å³å­æ ‘==ï¼Œ==å†é€’å½’å·¦å­æ ‘==**ï¼Œè¿™æ ·å¤„ç†é¡ºåºå°±æ˜¯**ä»å¤§åˆ°å°**äº†ã€‚

```java
// å…¨å±€å˜é‡ï¼Œç”¨äºè®°å½•ç´¯åŠ å’Œ
int sum = 0;

public TreeNode convertBST(TreeNode root) {
    // Base case
    if(root == null) return null;
    // å…ˆé€’å½’å³å­æ ‘
    convertBST(root.right);
    // ä¸æ–­ç´¯ç§¯æ›´æ–°sumå€¼
    sum = sum + root.val;
    // å°†å½“å‰éå†è¿‡çš„èŠ‚ç‚¹å€¼è®¾ç½®ä¸ºsum
    root.val = sum;
    // å†é€’å½’å·¦å­æ ‘
    convertBST(root.left);
    return root;
}
```



### äºŒå‰æ ‘æ„é€ ä¸å˜æ¢ç±»é¢˜ç›®

æŠ€å·§ï¼š

- å¯ä»¥è€ƒè™‘ä½¿ç”¨ **HashMap** å­˜å‚¨**ä½ç½®å…³ç³»**ã€‚
- é€šè¿‡æ•°ç»„é€’å½’æ„é€ äºŒå‰æ ‘æ˜¯æœ‰å¥—è·¯æ¨¡æ¿çš„ï¼Œæ³¨æ„æ¯”è¾ƒä¸‹é¢å‡ ä¸ªé¢˜ã€‚

#### 108.æœ‰åºæ•°ç»„æ„é€ æˆæœç´¢äºŒå‰æ ‘ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree)

å°†ä¸€ä¸ªæŒ‰ç…§**å‡åºæ’åˆ—**çš„æœ‰åºæ•°ç»„ï¼Œè½¬æ¢ä¸ºä¸€æ£µ**é«˜åº¦å¹³è¡¡**äºŒå‰æœç´¢æ ‘ã€‚æœ¬é¢˜ä¸­ï¼Œä¸€ä¸ªé«˜åº¦å¹³è¡¡äºŒå‰æ ‘æ˜¯æŒ‡ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼**ä¸è¶…è¿‡ 1**ã€‚

ç¤ºä¾‹ï¼šç»™å®šæœ‰åºæ•°ç»„: [-10, -3, 0, 5, 9]ã€‚ä¸€ä¸ª**å¯èƒ½çš„ç­”æ¡ˆ**æ˜¯ï¼š[0, -3, 9, -10, null, 5]ï¼Œå®ƒå¯ä»¥è¡¨ç¤ºä¸‹é¢è¿™ä¸ªé«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚

          0
         / \
        -3  9
       /   /
     -10  5

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

ç”±äºæ˜¯é«˜åº¦å¹³è¡¡ï¼Œæ‰€ä»¥è€ƒè™‘ä½¿ç”¨**äºŒåˆ†æ–¹å¼**è¿›è¡Œã€‚æ¯æ¬¡å–æ•°ç»„çš„**ä¸­é—´å…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹**ï¼Œæ ¹èŠ‚ç‚¹**å·¦è¾¹çš„ä½œä¸ºå·¦å­æ ‘**ï¼Œå³è¾¹çš„ä½œä¸º**å³å­æ ‘**ã€‚å¦‚æœåªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆ**ç›´æ¥è¿”å›è¿™ä¸ªç»“ç‚¹**ã€‚

```java
public TreeNode sortedArrayToBST(int[] nums) {
    return helper(nums, 0, nums.length - 1);
}

// è¾…åŠ©æ•°ç»„ï¼Œä¼ å…¥numsï¼Œéœ€è¦æ„é€ æ ‘çš„èµ·å§‹å’Œç»“æŸç´¢å¼•
private TreeNode helper(int[] nums, int start, int end) {
    // Base case
    if(start > end) return null;
    // ä»…ä¸€ä¸ªå…ƒç´ åˆ™ç›´æ¥è¿”å›è¿™ä¸ªå…ƒç´ æ„æˆçš„ç»“ç‚¹
    if(start == end) return new TreeNode(nums[start]);
    // å¦åˆ™ç”¨ä¸­é—´ç»“ç‚¹æ„é€ æ ¹èŠ‚ç‚¹,è¿™æ ·æ‰æ˜¯é«˜åº¦å¹³è¡¡çš„
    int mid = (start + end) / 2;
    TreeNode root = new TreeNode(nums[mid]);
    // é€’å½’æ„é€ å·¦å³å­æ ‘
    root.left = helper(nums, start, mid - 1);
    root.right = helper(nums, mid + 1, end);
    // è¿”å›æ„é€ å¥½çš„æ ¹ç»“ç‚¹
    return root;
}
```

è¿™ä¸ªé¢˜å¯ä»¥å½“åš**é€šè¿‡æ•°ç»„é€’å½’æ„é€ äºŒå‰æ ‘**çš„**æ¨¡æ¿**ã€‚

#### 654.æœ€å¤§äºŒå‰æ ‘ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/maximum-binary-tree)

ç»™å®šä¸€ä¸ª**ä¸å«é‡å¤å…ƒç´ **çš„æ•´æ•°æ•°ç»„ã€‚ä¸€ä¸ªä»¥æ­¤æ•°ç»„æ„å»ºçš„**æœ€å¤§äºŒå‰æ ‘**å®šä¹‰å¦‚ä¸‹ï¼š

- äºŒå‰æ ‘çš„**æ ¹**æ˜¯æ•°ç»„ä¸­çš„**æœ€å¤§å…ƒç´ **ã€‚
- **å·¦å­æ ‘**æ˜¯é€šè¿‡æ•°ç»„ä¸­æœ€å¤§å€¼**å·¦è¾¹éƒ¨åˆ†æ„é€ å‡ºçš„æœ€å¤§äºŒå‰æ ‘**ã€‚
- **å³å­æ ‘**æ˜¯é€šè¿‡æ•°ç»„ä¸­æœ€å¤§å€¼å³**è¾¹éƒ¨åˆ†æ„é€ å‡ºçš„æœ€å¤§äºŒå‰æ ‘**ã€‚
- é€šè¿‡ç»™å®šçš„æ•°ç»„æ„å»ºæœ€å¤§äºŒå‰æ ‘ï¼Œå¹¶ä¸”è¾“å‡ºè¿™ä¸ªæ ‘çš„**æ ¹èŠ‚ç‚¹**ã€‚

ç¤ºä¾‹ ï¼šè¾“å…¥ï¼š[3, 2, 1, 6, 0, 5]ã€‚è¾“å‡ºï¼šè¿”å›ä¸‹é¢è¿™æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ã€‚

         6
       /   \
       3     5
        \    / 
         2  0   
           \
            1

##### 2. é¢˜è§£

è¿™ä¸ªé¢˜å°±æ˜¯å¥—ç”¨äº†**ä¸Šé¢˜çš„æ¨¡æ¿**ï¼Œåªæ˜¯**æ„é€ æ¡ä»¶æœ‰æ‰€å˜åŒ–**ã€‚

###### (1) é€’å½’æ³•

ç›´æ¥å¯»æ‰¾å½“å‰æœ‰æ•ˆæ•°ç»„ä¸­çš„æœ€å¤§å€¼ä½œä¸º**æ ¹ç»“ç‚¹**ï¼Œç„¶åä»¥æ­¤å¤„çš„ç´¢å¼•ä¸ºåˆ†ç•Œçº¿ï¼Œæ„é€ å…¶å·¦å³å­æ ‘ã€‚

```java
int[] nums;

public TreeNode constructMaximumBinaryTree(int[] nums) {
    this.nums = nums;
    // ç¬¬ä¸€æ¬¡çš„èŒƒå›´æ˜¯0åˆ°length
    return helper(0, nums.length);
}

public TreeNode helper(int start, int end) {
    // Base case
    if (start >= end) return null;

    // éå†æ•°ç»„å¯»æ‰¾å½“å‰èŒƒå›´ä¸‹çš„æœ€å¤§å€¼ä½œä¸ºåˆ†ç•Œçº¿
    int max = nums[start];
    int maxIndex = start;
    for (int i = start + 1; i < end; i++) {
        if (max < nums[i]) {
            // æ›´æ–°æœ€å¤§æ•°å€¼å’Œç´¢å¼•å€¼
            max = nums[i];
            maxIndex = i;
        }
    }
    // ä½¿ç”¨æœ€å¤§å€¼æ„é€ ä¸€ä¸ªæ ¹ç»“ç‚¹
    TreeNode root = new TreeNode(max);
    // é€’å½’è®¾ç½®å·¦å³å­æ ‘
    root.left = helper(start, maxIndex);
    root.right = helper(maxIndex + 1, end);
    return root;
}
```

#### 1008.ä½¿ç”¨å…ˆåºéå†æ„é€ æœç´¢äºŒå‰æ ‘ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/)

**è¿”å›**ä¸ç»™å®š**å…ˆåºéå†** `preorder` ç›¸åŒ¹é…çš„**äºŒå‰æœç´¢æ ‘**ï¼ˆbinary **search** treeï¼‰çš„**æ ¹ç»“ç‚¹ã€‚**

```java
è¾“å…¥ï¼š[8,5,1,7,10,12]
è¾“å‡ºï¼š[8,5,10,1,7,null,12]
```

<img src="assets/image-20200422102829690.png" alt="image-20200422102829690" style="zoom:50%;" />

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

**å…ˆåºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä¸€å®šæ˜¯æœç´¢äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹**ã€‚æ ¹ç»“ç‚¹åé¢çš„å€¼è¢«**åˆ†ä¸ºå·¦å­æ ‘éƒ¨åˆ†**ï¼ˆå°äºæ ¹ï¼‰å’Œ**å³å­æ ‘**ï¼ˆå¤§äºæ ¹ï¼‰éƒ¨åˆ†ï¼ˆä¸¥æ ¼åŒºåˆ†ï¼‰ã€‚æ‰¾åˆ°æ¯”**æ ¹å°**çš„å€¼ä¸ºæ ¹çš„**å·¦å­æ ‘**ï¼Œæ‰¾åˆ°æ¯”æ ¹å¤§çš„å€¼ä¸º**å³å­æ ‘**ã€‚é€’å½’æ‰¾å‡ºæ‰€æœ‰æ ‘å½¢å…³ç³»ã€‚è¿”å›å³ä¸ºäºŒå‰æœç´¢æ ‘ã€‚

**é€’å½’å¥—è·¯è¿˜æ˜¯è›®å¤š**çš„ï¼Œéƒ½æ˜¯é»˜è®¤å¾—åˆ°**ä¸‹ä¸€çº§çš„ä¿¡æ¯ç„¶åæ„é€ è‡ªå·±çš„ä¿¡æ¯è¿”å›**ã€‚

```java
public TreeNode bstFromPreorder3(int[] preorder) {
    return buildBST(preorder, 0, preorder.length - 1);
}

// æ•°ç»„çš„èŒƒå›´ä»leftåˆ°right
private TreeNode buildBST(int[] preorder, int left, int right) {
    if (left > right) return null;
    // æ„é€ ä¸€ä¸ªç»“ç‚¹
    TreeNode root = new TreeNode(preorder[left]);
    // å¦‚æœleft==rightè¯´æ˜åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œæ²¡æ³•å†æ‹†åˆ†äº†
    if (left == right) return root;
    int index = left;
    // æ‹†åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†æ˜¯æ¯”preorder[left]å¤§çš„ï¼Œä¸€éƒ¨åˆ†æ˜¯æ¯”preorder[left]å°çš„,æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„
    while (index + 1 <= right && preorder[index + 1] < preorder[left])
        index++;
    // åŒºé—´[left + 1ï¼Œi]æ‰€æœ‰å…ƒç´ éƒ½åœ¨rootèŠ‚ç‚¹çš„å·¦å­æ ‘
    // åŒºé—´[i + 1ï¼Œright]æ‰€æœ‰å…ƒç´ éƒ½åœ¨rootèŠ‚ç‚¹çš„å³å­æ ‘
    root.left = buildBST(preorder, left + 1, index);
    root.right = buildBST(preorder, index + 1, right);
    return root;
}
```

å†æ¥ä¸€ç§é€’å½’å†™æ³•ï¼š

```java
int index = 0;
int[] preOrder;
int len;

public TreeNode bstFromPreorder(int[] preOrder) {
    this.preOrder = preOrder;
    len = preOrder.length;
    return helper(Integer.MIN_VALUE, Integer.MAX_VALUE);
}

// é€’å½’æ„é€ ï¼šæ•´ä½“æ˜¯çº¿åºéå†
public TreeNode helper(int lower, int upper) {
    // å½“å…¨éƒ¨å…ƒç´ éƒ½ç”¨äº†å°±æ˜¯æ„é€ å¥½äº†
    if (index == len) return null;
    // å–ä¸€ä¸ªå€¼
    int val = preOrder[index];
    // å¦‚æœå½“å‰å€¼ä¸ç¬¦åˆæœç´¢äºŒå‰æ ‘çš„ç‰¹æ€§
    if (val < lower || val > upper) return null;
    index++;
    // é€’å½’æ„é€ äºŒå‰æ ‘
    TreeNode root = new TreeNode(val);
    root.left = helper(lower, val);
    root.right = helper(val, upper);
    return root;
}
```

è¿˜å¯ä»¥å‚ç…§**å…ˆåºéå†çš„æ–¹å¼æŠŠæ•°ç»„å…ƒç´ ä¸€ä¸ªä¸ªå–**å‡ºæ¥ï¼Œä¹Ÿå¾ˆå¥½ç†è§£ï¼Œç›´æ¥ä¸Šä»£ç ã€‚

```java
int index = 0;

public TreeNode bstFromPreorder(int[] preorder) {
    return bstFromPreorder(preorder, Integer.MAX_VALUE);
}

public TreeNode helper(int[] preorder, int max) {
    // Base case
    if (index == preorder.length || preorder[index] > max)
        return null;
    //æŠŠæ•°ç»„ä¸­çš„å…ƒç´ ä¸€ä¸ªä¸ªå–å‡ºæ¥åˆ›å»ºèŠ‚ç‚¹
    TreeNode root = new TreeNode(preorder[index++]);
    //å·¦å­æ ‘çš„æœ€å¤§å€¼ä¸èƒ½è¶…è¿‡root.val
    root.left = helper(preorder, root.val);
    //å³å­æ ‘çš„æœ€å¤§å€¼ä¸èƒ½è¶…è¿‡max
    root.right = helper(preorder, max);
    return root;
}
```

---

#### 106.ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal)

æ ¹æ®ä¸€æ£µæ ‘çš„**ä¸­åºéå†ä¸ååºéå†**æ„é€ äºŒå‰æ ‘ã€‚æ³¨æ„ï¼šä½ å¯ä»¥å‡è®¾æ ‘ä¸­**æ²¡æœ‰é‡å¤**çš„å…ƒç´ ã€‚ä¾‹å¦‚ï¼Œç»™å‡ºï¼š

```java
ä¸­åºéå† inorder = [9,3,15,20,7]
ååºéå† postorder = [9,15,7,20,3]
```

è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š

    	3
       / \
      9  20
        /  \
       15   7

##### 2. é¢˜è§£

å›¾è§£å¯ä»¥çœ‹çœ‹è¿™ä¸ªï¼šhttps://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/ è´¼ 6ã€‚

æ ¹æ®ä¸­åºéå†å’Œåç»­éå†çš„ç‰¹æ€§å¯¹æ ‘çš„è¿˜åŸè¿‡ç¨‹åˆ†æï¼š

- é¦–å…ˆåœ¨**ååº**éå†åºåˆ—ä¸­æ‰¾åˆ°**æ ¹èŠ‚ç‚¹(æœ€åä¸€ä¸ªå…ƒç´ )**ã€‚
- æ ¹æ®**æ ¹èŠ‚ç‚¹**åœ¨**ä¸­åº**éå†åºåˆ—ä¸­æ‰¾åˆ°**æ ¹èŠ‚ç‚¹çš„ä½ç½®ã€‚**
- æ ¹æ®æ ¹èŠ‚ç‚¹çš„ä½ç½®å°†**ä¸­åºéå†åºåˆ—åˆ†ä¸ºå·¦å­æ ‘å’Œå³å­æ ‘ã€‚**
- æ ¹æ®**æ ¹èŠ‚ç‚¹**çš„ä½ç½®ç¡®å®š**å·¦å­æ ‘å’Œå³å­æ ‘**åœ¨ä¸­åºæ•°ç»„å’Œåç»­æ•°ç»„ä¸­çš„**å·¦å³è¾¹ç•Œä½ç½®**ã€‚ï¼ˆé‡è¦ï¼ï¼ï¼‰ç¡®å®šè¾¹ç•Œä¹‹åå°†å·¦å³è¾¹ç•Œçš„æ•°ç»„ä¼ å…¥é€’å½’å‡½æ•°ã€‚
- **é€’å½’æ„é€ å·¦å­æ ‘å’Œå³å­æ ‘**ã€‚
- è¿”å›æ ¹èŠ‚ç‚¹ç»“æŸã€‚

```java
// ä½¿ç”¨è¾…åŠ©çš„HashMapå­˜å‚¨å…ƒç´ ï¼Œé”®ä¸ºä¸­åºæ•°ç»„å…ƒç´ å€¼ï¼Œå€¼ä¸ºä¸­åºæ•°ç»„ç´¢å¼•
HashMap<Integer, Integer> postMap = new HashMap<>();

int[] post;

public TreeNode buildTree(int[] inOrder, int[] postOrder) {
    // å°†ä¸­åºæ•°ç»„çš„å€¼åŠå…¶å¯¹åº”çš„ç´¢å¼•å…¨éƒ¨æ”¾å…¥åˆ°Mapä¸­
    for (int i = 0; i < inOrder.length; i++) postMap.put(inOrder[i], i);
    post = postOrder;
    // ä½¿ç”¨è¾…åŠ©æ–¹æ³•
    return buildTree(0, inOrder.length - 1, 0, post.length - 1);
}


public TreeNode buildTree(int inStart, int inEnd, int postStart, int postEnd) {
    // Base case
    if (inEnd < inStart || postEnd < postStart) return null;
    // æ ¹èŠ‚ç‚¹ç­‰äºååºæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ å€¼
    int rootVal = post[postEnd];
    // æ„é€ æ ¹èŠ‚ç‚¹å¹¶é€’å½’è®¾ç½®å…¶å·¦å³å­ç»“ç‚¹
    TreeNode root = new TreeNode(rootVal);
    // ä»Mapä¸­æ‰¾åˆ°ç­‰äºè¿™ä¸ªå€¼çš„å…ƒç´ çš„ä¸­åºæ•°ç»„ç´¢å¼•
    int rootIndex = postMap.get(rootVal);
    // åˆ†åˆ«æ„é€ å·¦å³å­æ ‘ å·¦å³å­æ ‘çš„è¾¹ç•Œç¡®å®šæ˜¯æœ€é‡è¦çš„ è‡ªå·±ç”»ä¸ªå›¾çœ‹çœ‹ï¼
    root.left = buildTree(inStart, rootIndex - 1, postStart, postStart + rootIndex - inStart - 1);
    root.right = buildTree(rootIndex + 1, inEnd, postStart + rootIndex - inStart, postEnd - 1);
    // è¿”å›æ„é€ å¥½çš„æ ¹èŠ‚ç‚¹
    return root;
}
```

å¦ä¸€ç§é€’å½’å†™æ³•ã€‚

```java
int postIndex;
int[] postOrder;
int[] inOrder;
HashMap<Integer, Integer> indexMap = new HashMap<Integer, Integer>();

public TreeNode buildTree2(int[] inOrder, int[] postOrder) {
    this.postOrder = postOrder;
    this.inOrder = inOrder;
    // ååºæ•°ç»„çš„æœ€åä¸€ä¸ªæ•°æ˜¯æ ¹ç»“ç‚¹
    postIndex = postOrder.length - 1;

    // å°†ä¸­åºæ•°ç»„çš„å€¼åŠå…¶å¯¹åº”çš„ç´¢å¼•æ”¾å…¥Mapä¸­
    int index = 0;
    for (Integer val : inOrder) indexMap.put(val, index++);

    return helper(0, inOrder.length - 1);
}

public TreeNode helper(int inLeft, int inRight) {
    // Base case
    if (inLeft > inRight) return null;

    // æ‰¾åˆ°ååºæ•°ç»„çš„æœ€åä¸€ä¸ªä½œä¸ºæ ¹å…ƒç´ 
    int rootVal = postOrder[postIndex];
    // æ„é€ æ ¹ç»“ç‚¹
    TreeNode root = new TreeNode(rootVal);
    // æ‰¾åˆ°ä¸­åºæ•°ç»„ä¸­æ ¹ç»“ç‚¹çš„ç´¢å¼•
    int index = indexMap.get(rootVal);
    // recursion
    postIndex--;
    // é€’å½’æ„é€ å·¦å³å­æ ‘
    root.right = helper(index + 1, inRight);
    root.left = helper(inLeft, index - 1);
    return root;
}
```

---

#### 897.é€’å¢é¡ºåºæŸ¥æ‰¾æ ‘ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/increasing-order-search-tree)

ç»™ä½ ä¸€ä¸ªæ ‘ï¼Œè¯·ä½  **æŒ‰ä¸­åºéå†** é‡æ–°æ’åˆ—æ ‘ï¼Œä½¿æ ‘ä¸­**æœ€å·¦è¾¹çš„ç»“ç‚¹ç°åœ¨æ˜¯æ ‘çš„æ ¹**ï¼Œå¹¶ä¸”æ¯ä¸ªç»“ç‚¹æ²¡æœ‰å·¦å­ç»“ç‚¹ï¼Œåªæœ‰ä¸€ä¸ªå³å­ç»“ç‚¹ã€‚ï¼ˆé€€åŒ–æˆä¸€ä¸ªé“¾è¡¨ï¼‰

è¾“å…¥ï¼š[5, 3, 6, 2, 4, null, 8, 1, null, null, null, 7, 9]

          5
         / \
        3    6
       / \    \
      2   4    8
     /        / \ 
    1        7   9


è¾“å‡ºï¼š[1, null, 2, null, 3, null, 4, null, 5, null, 6, null, 7, null, 8, null, 9]

```java
 1
  \
   2
    \
     3
      \
       4
        \
         5
          \
           6
            \
             7
              \
               8
                \
                 9  
```

##### 2. é¢˜è§£

å¯ä»¥ç›´æ¥æ–°å»ºä¸€é¢—æ ‘ï¼Œç›´æ¥ç”¨**ä¸­åºéå†**çš„æ–¹å¼è¿›è¡Œæ„é€ ã€‚ä½†æ˜¯è¿™æ ·ç©ºé—´å¤æ‚åº¦æ¯”è¾ƒé«˜ã€‚

è¿™é‡Œç›´æ¥ä½¿ç”¨**é€’å½’æ–¹å¼**ä¿®æ”¹æŒ‡é’ˆï¼Œ666ã€‚

```java
// curç»“ç‚¹æ²¿ç€é“¾è¡¨ç§»åŠ¨è¿›è¡Œè®¾ç½®
TreeNode cur;
public TreeNode increasingBST(TreeNode root) {
    // å¼•å…¥ä¸€ä¸ªdummyèŠ‚ç‚¹
    TreeNode dummy = new TreeNode(0);
    cur = dummy;
    // ä¸­åºéå†é€’å½’æ„é€ 
    process(root);
    // è¿”å›å³å­èŠ‚ç‚¹
    return dummy.right;
}

// æ•´ä½“ä¸­åºéå†çš„æ¶æ„ï¼Œç±»ä¼¼ç§»åŠ¨é“¾è¡¨
public void process(TreeNode node) {
    // Base case
    if (node == null) return;
    process(node.left);
    // curçš„å·¦ç»“ç‚¹éƒ½ä¸ºnull
    node.left = null;
    // æŠŠcurèŠ‚ç‚¹çš„å³å˜æˆå½“å‰èŠ‚ç‚¹node
    cur.right = node;
    // ä¸æ–­ç§»åŠ¨curèŠ‚ç‚¹åˆ°é“¾è¡¨å°¾éƒ¨
    cur = node;
    process(node.right);
}
```

#### 1325.åˆ é™¤ç»™å®šå€¼çš„å¶å­èŠ‚ç‚¹ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/delete-leaves-with-a-given-value/)

ç»™ä½ ä¸€æ£µ**ä»¥ root ä¸ºæ ¹**çš„äºŒå‰æ ‘å’Œä¸€ä¸ª**æ•´æ•° target** ï¼Œè¯·ä½ åˆ é™¤**æ‰€æœ‰å€¼ä¸º target çš„ å¶å­èŠ‚ç‚¹** ã€‚æ³¨æ„ï¼Œä¸€æ—¦åˆ é™¤å€¼ä¸º target çš„**å¶å­èŠ‚ç‚¹**ï¼Œå®ƒçš„çˆ¶èŠ‚ç‚¹å°±å¯èƒ½**å˜æˆå¶å­èŠ‚ç‚¹**ï¼›å¦‚æœæ–°å¶å­èŠ‚ç‚¹çš„**å€¼æ°å¥½ä¹Ÿæ˜¯ target** ï¼Œé‚£ä¹ˆè¿™ä¸ªèŠ‚ç‚¹**ä¹Ÿåº”è¯¥è¢«åˆ é™¤**ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä½ éœ€è¦**é‡å¤æ­¤è¿‡ç¨‹ç›´åˆ°ä¸èƒ½ç»§ç»­åˆ é™¤**ã€‚

<img src="assets/image-20200422130531049.png" alt="image-20200422130531049" style="zoom:60%;" />

<img src="assets/image-20200422130604081.png" alt="image-20200422130604081" style="zoom:70%;" />

<img src="assets/image-20200422130619433.png" alt="image-20200422130619433" style="zoom:80%;" />

<img src="assets/image-20200422130604081-1590921871455.png" alt="image-20200422130604081" style="zoom:70%;" />

<img src="assets/image-20200422130619433-1590921858661.png" alt="image-20200422130619433" style="zoom:77%;" />

##### 2. é¢˜è§£

ç”±äºéœ€è¦åˆ é™¤æ‰€æœ‰å€¼ä¸º target çš„**å¶å­èŠ‚ç‚¹**ï¼Œé‚£ä¹ˆçš„æ“ä½œ**é¡ºåº**åº”å½“ä»äºŒå‰æ ‘çš„**å¶å­èŠ‚ç‚¹å¼€å§‹**ï¼Œ**é€æ­¥å‘ä¸Š**ç›´åˆ°äºŒå‰æ ‘çš„æ ¹ä¸ºæ­¢ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨**é€’å½’**çš„æ–¹æ³•éå†æ•´é¢—äºŒå‰æ ‘ï¼Œå¹¶åœ¨**å›æº¯æ—¶**è¿›è¡Œåˆ é™¤æ“ä½œã€‚è¿™æ ·å¯¹äºäºŒå‰æ ‘ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œå®ƒ**çš„å­èŠ‚ç‚¹ä¸€å®šå…ˆäºå®ƒè¢«æ“ä½œã€‚è¿™å…¶å®ä¹Ÿå°±æ˜¯äºŒå‰æ ‘çš„ååºéå†**ã€‚

å…·ä½“åœ°ï¼Œå½“å›æº¯åˆ°æŸä¸ªèŠ‚ç‚¹ u æ—¶ï¼Œå¦‚æœ u çš„å·¦å³å­©å­å‡ä¸å­˜åœ¨ï¼ˆè¿™é‡Œæœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€æ˜¯èŠ‚ç‚¹ u çš„å­©å­æœ¬æ¥å°±ä¸å­˜åœ¨ï¼ŒäºŒæ˜¯èŠ‚ç‚¹ u çš„å­©å­å˜æˆäº†å¶å­èŠ‚ç‚¹å¹¶ä¸”å€¼ä¸º targetï¼Œå¯¼è‡´å…¶è¢«åˆ é™¤ï¼‰ï¼Œå¹¶ä¸”å€¼ä¸º targetï¼Œé‚£ä¹ˆæˆ‘ä»¬**è¦åˆ é™¤èŠ‚ç‚¹ u**ï¼Œé€’å½’å‡½æ•°çš„è¿”å›å€¼ä¸º**ç©ºèŠ‚ç‚¹**ï¼›å¦‚æœèŠ‚ç‚¹ u **ä¸éœ€è¦è¢«åˆ é™¤**ï¼Œé‚£ä¹ˆé€’å½’å‡½æ•°çš„**è¿”å›å€¼ä¸ºèŠ‚ç‚¹ u æœ¬èº«**ã€‚

```java
// å…ˆå¤„ç†å¶å­æ‰€ä»¥æ•´ä¸ªæ˜¯ååºéå†çš„è¿‡ç¨‹
public TreeNode removeLeafNodes(TreeNode root, int target) {
    // Base case
    if (root == null) return null;
    // é€’å½’è®¾ç½®ç»“ç‚¹çš„å·¦å³ç»“ç‚¹å€¼
    root.left = removeLeafNodes(root.left, target);
    root.right = removeLeafNodes(root.right, target);
    // å¦‚æœæ˜¯å­ç»“ç‚¹ä¸”åˆšå¥½éœ€è¦åˆ é™¤ï¼Œåˆ™è¿”å›nullï¼Œå¦åˆ™è¿”å›rootæœ¬èº«
    // åˆ¤æ–­æ˜¯å¦æ˜¯ç­‰äºtargetçš„å­èŠ‚ç‚¹
    if (root.left == null && root.right == null && root.val == target) {
        // ç›´æ¥è¿”å›nullä»£è¡¨åˆ é™¤
        return null;
    }
    // è¿™ä¸ªç»“ç‚¹ä¸åˆ é™¤åˆ™ç›´æ¥è¿”å›
    return root;
}
```

#### 814.äºŒå‰æ ‘å‰ªæã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/binary-tree-pruning)

ç»™å®šäºŒå‰æ ‘æ ¹ç»“ç‚¹ root ï¼Œæ­¤å¤–æ ‘çš„æ¯ä¸ªç»“ç‚¹çš„å€¼**è¦ä¹ˆæ˜¯ 0ï¼Œè¦ä¹ˆæ˜¯ 1**ã€‚è¿”å›ç§»é™¤äº†**æ‰€æœ‰ä¸åŒ…å« 1** çš„å­æ ‘çš„åŸäºŒå‰æ ‘ã€‚

( èŠ‚ç‚¹ X çš„å­æ ‘ä¸º X æœ¬èº«ï¼Œä»¥åŠæ‰€æœ‰ X çš„åä»£ã€‚)

<img src="assets/image-20200808212416709.png" alt="image-20200808212416709" style="zoom:60%;" />

<img src="assets/image-20200808212434582.png" alt="image-20200808212434582" style="zoom:67%;" />

##### 2. é¢˜è§£

###### (1) é€’å½’

æ•´ä¸ªè¿‡ç¨‹æ˜¯è‡ªåº•å‘ä¸Šçš„æš´åŠ›é€’å½’çš„ç»“æ„ï¼Œä»ä¸‹å¾€ä¸Šåˆ¤æ–­å«ä¸å« 1ï¼Œå¦‚æœéƒ½ä¸å« 1ï¼Œé‚£ç›´æ¥åˆ æ‰ï¼Œä¹Ÿå°±æ˜¯è®¾ç½®ä¸º nullã€‚

```java
public TreeNode pruneTree(TreeNode root) {
    return containsOne(root) ? root : null;
}

// æ•´ä¸ªè¿‡ç¨‹æ˜¯æš´åŠ›é€’å½’çš„ç»“æ„
public boolean containsOne(TreeNode node) {
    // Base case
    if (node == null) return false;
    // å·¦è¾¹å’Œå³è¾¹å­æ ‘æ˜¯å¦å«1
    boolean left = containsOne(node.left);
    boolean right = containsOne(node.right);
    // ä¸å«1åˆ™å·¦å³ç›´æ¥åˆ æ‰,ä¹Ÿå°±æ˜¯è®¾ç½®ä¸ºnull
    if (!left) node.left = null;
    if (!right) node.right = null;
    // è‡ªå·±çš„æ ‘æ˜¯å¦å«1
    return node.val == 1 || left || right;
}
```

#### 297.äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–ã€å›°éš¾ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

è¯·å®ç°ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«ç”¨æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘ã€‚

äºŒå‰æ ‘çš„åºåˆ—åŒ–æ˜¯æŒ‡ï¼šæŠŠä¸€æ£µäºŒå‰æ ‘æŒ‰ç…§æŸç§éå†æ–¹å¼çš„ç»“æœä»¥æŸç§æ ¼å¼ä¿å­˜ä¸ºå­—ç¬¦ä¸²ï¼Œä»è€Œä½¿å¾—å†…å­˜ä¸­å»ºç«‹èµ·æ¥çš„äºŒå‰æ ‘å¯ä»¥æŒä¹…ä¿å­˜ã€‚åºåˆ—åŒ–å¯ä»¥åŸºäºå…ˆåºã€ä¸­åºã€ååºã€å±‚åºçš„äºŒå‰æ ‘éå†æ–¹å¼æ¥è¿›è¡Œä¿®æ”¹ï¼Œåºåˆ—åŒ–çš„ç»“æœæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåºåˆ—åŒ–æ—¶é€šè¿‡ æŸç§ç¬¦å·è¡¨ç¤º**ç©ºèŠ‚ç‚¹ï¼ˆ#ï¼‰ï¼Œä»¥  ï¼**è¡¨ç¤ºä¸€ä¸ª**ç»“ç‚¹å€¼çš„ç»“æŸ**ï¼ˆvalue!ï¼‰ã€‚

äºŒå‰æ ‘çš„ååºåˆ—åŒ–æ˜¯æŒ‡ï¼šæ ¹æ®æŸç§éå†é¡ºåºå¾—åˆ°çš„åºåˆ—åŒ–å­—ç¬¦ä¸²ç»“æœ strï¼Œ**é‡æ„äºŒå‰æ ‘**ã€‚

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

ä½¿ç”¨**å…ˆåºéå†**çš„æ–¹å¼åºåˆ—åŒ–ä¸ååºåˆ—åŒ–äºŒå‰æ ‘ï¼Œå¦‚ä¸‹ã€‚

```java
private String deserializeStr;

// å‰åºéå†æ–¹å¼åºåˆ—åŒ–
public String serialize(TreeNode root) {
    if (root == null)
        return "#";
    return root.val + "!" + serialize(root.left) + "!" + serialize(root.right);
}

public TreeNode deserialize(String str) {
    deserializeStr = str;
    return deserialize();
}

// ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘
private TreeNode deserialize() {
    // Base case
    if (deserializeStr.length() == 0) return null;
    // æ‰¾åˆ°ä¸‹ä¸€ä¸ªç»“ç‚¹çš„å€¼
    int index = deserializeStr.indexOf(" ");
    String nodeString = index == -1 ? deserializeStr : deserializeStr.substring(0, index);
    // æ›´æ–°åŸå§‹çš„ååºåˆ—åŒ–å­—ç¬¦ä¸²
    deserializeStr = index == -1 ? "" : deserializeStr.substring(index + 1);
    // å¦‚æœæ˜¯#ä»£è¡¨æ˜¯nullå€¼
    if (nodeString.equals("#")) return null;
    int val = Integer.parseInt(nodeString);
    TreeNode root = new TreeNode(val);
    // é€’å½’è§£æå·¦å³å­ç»“ç‚¹
    root.left = deserialize();
    root.right = deserialize();
    // ç„¶åè¿”å›è‡ªå·±
    return root;
}
```

###### (2) å±‚åºæ–¹å¼

åˆ©ç”¨**å±‚åºéå†**çš„æ–¹å¼å®ç°åºåˆ—åŒ–ä¸ååºåˆ—åŒ–ã€‚é¢è¯•ç”¨è¿™ä¸ªï¼

```java
public String serialize2(TreeNode root) {
    if (root == null) return "";
    StringBuilder res = new StringBuilder();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        if (node != null) {
            res.append(node.val + "#");
            // è¿™é‡Œå³ä½¿æ˜¯nullèŠ‚ç‚¹ä¹Ÿéœ€è¦åŠ è¿›å»
            queue.add(node.left);
            queue.add(node.right);
        } else {
            // ç©ºèŠ‚ç‚¹å•ç‹¬åºåˆ—åŒ–
            res.append("null#");
        }
    }
    res.deleteCharAt(res.length() - 1);
    return res.toString();
}

public TreeNode deserialize2(String data) {
    if (data.length() == 0) return null;
    // æ‹†åˆ†æˆç»“ç‚¹å€¼
    String[] nums = data.split("#");
    // æ„é€ æ ¹ç»“ç‚¹
    TreeNode root = new TreeNode(Integer.parseInt(nums[0]));
    // ä¹Ÿæ˜¯åˆ©ç”¨é˜Ÿåˆ—æ¥ä¸æ–­å‡ºé˜Ÿåˆ—è¿›è¡Œè®¾ç½®
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int numIndex = 1;
    while (!queue.isEmpty()) {
        // å¼¹å‡ºæ ¹ç»“ç‚¹
        TreeNode node = queue.poll();
        // ä¸æ–­è®¾ç½®å…¶å·¦å³ç»“ç‚¹
        if (!"null".equals(nums[numIndex])) {
            node.left = new TreeNode(Integer.parseInt(nums[numIndex]));
            queue.add(node.left);
        }
        numIndex++;
        if (!"null".equals(nums[numIndex])) {
            node.right = new TreeNode(Integer.parseInt(nums[numIndex]));
            queue.add(node.right);
        }
        numIndex++;
    }
    return root;
}
```

#### ğŸ’¯226.äºŒå‰æ ‘çš„é•œåƒã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/invert-binary-tree)

ç¿»è½¬ä¸€æ£µäºŒå‰æ ‘ï¼Œå¾—åˆ°äºŒå‰æ ‘çš„**é•œåƒ**ã€‚è¾“å…¥ï¼š

     	  4
        /   \
      2     7
     / \   / \
    1   3 6   9

è¾“å‡ºï¼š

          4
        /   \
      7     2
     / \   / \
    9   6 3   1

##### 2. é¢˜è§£

è§‚å¯Ÿä¸€ä¸‹ï¼Œå…¶å®å°±æ˜¯**äº¤æ¢äº†æ¯ä¸ªç»“ç‚¹çš„å·¦å³å­æ ‘**ã€‚æ‰€ä»¥å¯ä»¥ç”¨**é€’å½’çš„æ–¹å¼ä»ä¸‹å¾€ä¸Šè¿›è¡Œäº¤æ¢**ï¼Œè¿™æ ·å…ˆæ“ä½œå­èŠ‚ç‚¹å†æ“ä½œæ ¹èŠ‚ç‚¹å°±æ˜¯å…¸å‹çš„**ååºéå†**ã€‚æ‰€ä»¥æ•´ä½“é€’å½’çš„æ¶æ„æ˜¯**ååºéå†**ã€‚

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    // å…ˆè·å–å·¦å³çš„å­æ ‘ä¿¡æ¯
    TreeNode right = invertTree(root.right);
    TreeNode left = invertTree(root.left);
    // åˆ†åˆ«è®¾ç½®ä¹‹åè¿”å›è‡ªå·±
    root.left = right;
    root.right = left;
    return root;
}
```

#### ğŸ’¯617.åˆå¹¶äºŒå‰æ ‘ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/merge-two-binary-trees)

ç»™å®šä¸¤ä¸ªäºŒå‰æ ‘ï¼Œæƒ³è±¡å½“ä½ å°†å®ƒä»¬ä¸­çš„ä¸€ä¸ªè¦†ç›–åˆ°å¦ä¸€ä¸ªä¸Šæ—¶ï¼Œä¸¤ä¸ªäºŒå‰æ ‘çš„ä¸€äº›èŠ‚ç‚¹ä¾¿ä¼š**é‡å **ã€‚ä½ éœ€è¦å°†ä»–ä»¬åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯å¦‚æœ**ä¸¤ä¸ªèŠ‚ç‚¹é‡å **ï¼Œé‚£ä¹ˆå°†ä»–ä»¬çš„**å€¼ç›¸åŠ ä½œä¸ºèŠ‚ç‚¹åˆå¹¶åçš„æ–°å€¼**ï¼Œå¦åˆ™ä¸ä¸º NULL çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚è¾“å…¥ï¼š

```java
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7      
```

è¾“å‡ºåˆå¹¶åçš„æ ‘ï¼š

```java
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

æ³¨æ„: åˆå¹¶å¿…é¡»ä»ä¸¤ä¸ªæ ‘çš„**æ ¹èŠ‚ç‚¹**å¼€å§‹ã€‚

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

å¯ä»¥å¯¹è¿™ä¸¤æ£µæ ‘**åŒæ—¶è¿›è¡Œå‰åºéå†**ï¼Œå¹¶å°†å¯¹åº”çš„èŠ‚ç‚¹è¿›è¡Œ**åˆå¹¶**ã€‚åœ¨éå†æ—¶ï¼Œå¦‚æœä¸¤æ£µæ ‘çš„å½“å‰èŠ‚ç‚¹**å‡ä¸ä¸ºç©º**ï¼Œå°±å°†å®ƒä»¬çš„å€¼è¿›è¡Œ**ç›¸åŠ **ï¼Œå¹¶å¯¹å®ƒä»¬çš„å·¦å­©å­å’Œå³å­©å­è¿›è¡Œ**é€’å½’åˆå¹¶**ï¼›å¦‚æœå…¶ä¸­**æœ‰ä¸€æ£µæ ‘ä¸ºç©º**ï¼Œé‚£ä¹ˆè¿”å›**å¦ä¸€é¢—æ ‘ä½œä¸ºç»“æœ**ï¼›å¦‚æœä¸¤æ£µæ ‘å‡ä¸ºç©ºï¼Œæ­¤æ—¶è¿”å›ä»»æ„ä¸€æ£µæ ‘å‡å¯ï¼ˆå› ä¸ºéƒ½æ˜¯ç©ºï¼‰ã€‚

ä¸‹é¢åˆå¹¶çš„æ—¶å€™æŠŠ t1 t2 çš„å€¼ç›´æ¥åˆå¹¶åˆ° t1 ä¹‹ä¸Šã€‚

[è¿‡ç¨‹å›¾è§£](https://leetcode-cn.com/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode/)

```java
public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
    // Base case:åªè¦å…¶ä¸­ä¸€ä¸ªä¸ºnullç›´æ¥è¿”å›å¦ä¸€ä¸ªå³å¯
    if (t1 == null) return t2;
    if (t2 == null) return t1;
    // å‡è®¾éƒ½åˆå¹¶åˆ°t1æ ‘ä¸Š
    t1.val = t1.val + t2.val;
    // é€’å½’å¹¶è·å–åˆ°å·¦å³å­æ ‘
    t1.left = mergeTrees(t1.left, t2.left);
    t1.right = mergeTrees(t1.right, t2.right);
    // è¿”å›åˆå¹¶åçš„æ ‘
    return t1;
}
```

###### (2) è¿­ä»£æ³•

ä¹Ÿå¯ä»¥ç”¨è¿­ä»£çš„æ–¹æ³•ã€‚é¦–å…ˆæŠŠä¸¤æ£µæ ‘çš„**æ ¹èŠ‚ç‚¹å…¥æ ˆ**ï¼Œæ ˆä¸­çš„**æ¯ä¸ªå…ƒç´ éƒ½ä¼šå­˜æ”¾ä¸¤ä¸ªæ ¹èŠ‚ç‚¹**ï¼Œå¹¶ä¸”**æ ˆé¡¶çš„å…ƒç´ è¡¨ç¤ºå½“å‰éœ€è¦å¤„ç†çš„èŠ‚ç‚¹**ã€‚åœ¨è¿­ä»£çš„æ¯ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬å–å‡ºæ ˆé¡¶çš„å…ƒç´ å¹¶æŠŠå®ƒç§»å‡ºæ ˆï¼Œå¹¶å°†å®ƒä»¬çš„å€¼**ç›¸åŠ **ã€‚éšååˆ†åˆ«è€ƒè™‘è¿™ä¸¤ä¸ªèŠ‚ç‚¹çš„**å·¦å­©å­å’Œå³å­©å­**ï¼Œå¦‚æœä¸¤ä¸ªèŠ‚ç‚¹**éƒ½æœ‰å·¦å­©å­**ï¼Œé‚£ä¹ˆå°±å°†å·¦å­©å­**å…¥æ ˆ**ï¼›å¦‚æœ**åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹æœ‰å·¦å­©å­**ï¼Œé‚£ä¹ˆå°†å…¶ä½œä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­©å­ï¼Œä¸å…¥æ ˆï¼›å¦‚æœéƒ½æ²¡æœ‰å·¦å­©å­ï¼Œé‚£ä¹ˆä¸ç”¨åšä»»ä½•äº‹æƒ…ã€‚å¯¹äºå³å­©å­åŒç†ã€‚æœ€åè¿”å›ç¬¬ä¸€æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ä½œä¸ºç­”æ¡ˆã€‚

```java
public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
    // Base case
    if (t1 == null) return t2;
    Stack<TreeNode[]> stack = new Stack<>();
    stack.push(new TreeNode[] {t1, t2});
    while (!stack.isEmpty()) {
        TreeNode[] t = stack.pop();
        // éƒ½ä¸ºç©º
        if (t[0] == null || t[1] == null) continue;
        t[0].val += t[1].val;
        if (t[0].left == null) {
            t[0].left = t[1].left;
        } else {
            stack.push(new TreeNode[] {t[0].left, t[1].left});
        }
        if (t[0].right == null) {
            t[0].right = t[1].right;
        } else {
            stack.push(new TreeNode[] {t[0].right, t[1].right});
        }
    }
    return t1;
}
```



### è·ç¦»ä¸è·¯å¾„ç›¸å…³é—®é¢˜

#### 112.æ ¹ç»“ç‚¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„æ€»åˆã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/path-sum)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘å’Œä¸€ä¸ª**ç›®æ ‡å’Œ**ï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨**æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹**çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Š**æ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡**å’Œã€‚è¯´æ˜ï¼šå¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚ç¤ºä¾‹ï¼šç»™å®šå¦‚ä¸‹äºŒå‰æ ‘ï¼Œä»¥åŠç›®æ ‡å’Œ sum = 22ã€‚

```java
          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
```

è¿”å› true, å› ä¸ºå­˜åœ¨ç›®æ ‡å’Œä¸º 22 çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ 5->4->11->2ã€‚

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

ç›´æ¥**å…ˆåºé€’å½’**ï¼Œæ¯ç»è¿‡ä¸€ä¸ªèŠ‚ç‚¹å°±å°†ç›®æ ‡å€¼å‡å»èŠ‚ç‚¹å€¼ï¼Œå¹¶ä¸ä¹‹åçš„èŠ‚ç‚¹å€¼å¯¹æ¯”ï¼Œå¦‚æœ**åˆšå¥½ç›¸ç­‰ä¸”ä¸ºå¶å­èŠ‚ç‚¹**ï¼Œåˆ™è®¤ä¸ºæ‰¾åˆ°ã€‚

```java
private boolean isFind = false;

public boolean hasPathSum(TreeNode root, int sum) {
    helper(root, sum);
    return isFind;
}

// æ•´ä½“ä¸­åºé€’å½’æ¨¡æ¿
private void helper(TreeNode root, int sum) {
    // Base case
    if(root == null) return;
    // å¦‚æœå½“å‰çš„sumç­‰äºç»“ç‚¹å€¼ä¸”å½“å‰æ­£å¥½ä¸ºæ ¹ç»“ç‚¹åˆ™æ‰¾åˆ°
    if(sum == root.val && (root.left == null && root.right == null)) isFind = true;
    helper(root.left, sum - root.val);
    helper(root.right, sum - root.val);
}
```

###### (2) è¿­ä»£æ³•

åˆ©ç”¨**æ ˆ**è¿›è¡Œã€‚

```java
public boolean hasPathSum2(TreeNode root, int sum) {
    if (root == null) return false;

    LinkedList<TreeNode> nodeStack = new LinkedList<>();
    LinkedList<Integer> sumStack = new LinkedList<>();
    nodeStack.add(root);
    sumStack.add(sum - root.val);
    TreeNode node;
    int currSum;
    while (!nodeStack.isEmpty() ) {
        node = nodeStack.pollLast();
        currSum = sumStack.pollLast();
        if ((node.right == null) && (node.left == null) && (currSum == 0)) return true;

        if (node.right != null) {
            nodeStack.add(node.right);
            sumStack.add(currSum - node.right.val);
        }
        if (node.left != null) {
            nodeStack.add(node.left);
            sumStack.add(currSum - node.left.val);
        }
    }
    return false;
}
```

#### 863.äºŒå‰æ ‘ä¸­æ‰€æœ‰è·ç¦»ä¸ºKçš„ç»“ç‚¹ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree)

ç»™å®šä¸€ä¸ª**äºŒå‰æ ‘**ï¼ˆå…·æœ‰æ ¹ç»“ç‚¹ rootï¼‰ï¼Œ ä¸€ä¸ª**ç›®æ ‡ç»“ç‚¹** **target** ï¼Œå’Œä¸€ä¸ª**æ•´æ•°å€¼ K** ã€‚è¿”å›**åˆ°ç›®æ ‡ç»“ç‚¹ target è·ç¦»ä¸º K** çš„**æ‰€æœ‰ç»“ç‚¹**çš„å€¼çš„åˆ—è¡¨ã€‚ ç­”æ¡ˆå¯ä»¥ä»¥**ä»»ä½•é¡ºåº**è¿”å›ã€‚

ç¤ºä¾‹ 1ï¼šè¾“å…¥ï¼šroot = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4],  target = 5, K = 2ã€‚è¾“å‡ºï¼š[7, 4, 1]

<img src="assets/image-20200503203003786.png" alt="image-20200503203003786" style="zoom:37%;" />

è§£é‡Šï¼šæ‰€æ±‚ç»“ç‚¹ä¸ºä¸ç›®æ ‡ç»“ç‚¹ï¼ˆ**å€¼ä¸º 5**ï¼‰è·ç¦»**ä¸º 2** çš„ç»“ç‚¹ï¼Œå€¼åˆ†åˆ«ä¸º 7ï¼Œ4ï¼Œä»¥åŠ 1ã€‚

##### 2. é¢˜è§£

###### (1) DFS+BFS

é¦–å…ˆ**æ¯ä¸ªç»“ç‚¹æ‰¾åˆ°å®ƒçš„çˆ¶ç»“ç‚¹**ç„¶åå­˜å‚¨åœ¨ hashmap<TreeNode(**å„¿å­**), TreeNode(**çˆ¶äº²**)> ä¸­ï¼Œæ ¹èŠ‚ç‚¹æ²¡æœ‰çˆ¶äº²ï¼Œæ‰€ä»¥**ä¸å­˜å…¥**é‡Œé¢ã€‚ç„¶åè¿™æ—¶å€™å°±å¯ä»¥æŠŠ**ç›®æ ‡èŠ‚ç‚¹ target çœ‹æˆä¸€ä¸ªæ–°çš„æ ¹èŠ‚ç‚¹**ï¼Œè¿™æ—¶å€™å°±æ˜¯ä¸€ä¸ª**æ–°æ ‘**ï¼Œè·ç¦»å®ƒä¸º K çš„ç»“ç‚¹ä¹Ÿå°±æ˜¯å¤„åœ¨ç¬¬ **K+1 å±‚çš„ç»“ç‚¹**(æ ¹åœ¨ç¬¬ä¸€å±‚)ï¼Œè¿™æ—¶å€™åªéœ€é‡‡ç”¨**å±‚åºéå†**ï¼Œæ‰¾åˆ°**ç¬¬ K+1 å±‚**çš„æ‰€æœ‰ç»“ç‚¹å³å¯ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œéå†åªèƒ½**ä» target å¼€å§‹**ä¸€ç›´å‘**ä¸‹ä¸€ä¸ªæ–¹å‘**çš„éå†ï¼Œæ‰€ä»¥é‡åˆ°åŸæ¥ target çš„**çˆ¶èŠ‚ç‚¹æ—¶ï¼Œä¸èƒ½å†è¿”å›æ¥å·¦å³å­æ ‘éå†äº†**ï¼Œä¹Ÿå°±æ˜¯çˆ¶èŠ‚ç‚¹åªèƒ½æ·»åŠ ä¸€æ¬¡ï¼Œæ‰€ä»¥ç”¨ä¸€ä¸ª set æ¥å­˜å‚¨**å·²ç»æ·»åŠ **çš„ç»“ç‚¹ï¼Œå†æ¬¡éå†æ—¶ï¼Œè¦çœ‹ç»“ç‚¹æ˜¯å¦å·²ç»åœ¨ set ä¸­ï¼Œä¸åœ¨æ‰èƒ½ç»§ç»­éå†ï¼Œå¦åˆ™è·³è¿‡ã€‚

```java
// å­˜æ”¾å½“å‰èŠ‚ç‚¹åŠå…¶çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆçš„Map
HashMap<TreeNode, TreeNode> map = new HashMap<>();

public List<Integer> distanceK(TreeNode root, TreeNode targetNode, int K) {
    // base case
    if (root == null || targetNode == null) return new ArrayList<>();

    // ç”¨äºè®°å½•å·²ç»è®¿é—®è¿‡çš„ç»“ç‚¹
    HashSet<TreeNode> set = new HashSet<>();
    // å­˜æ”¾ç­”æ¡ˆ
    List<Integer> resList = new LinkedList<>();
    // ä½¿ç”¨é˜Ÿåˆ—éå†
    Queue<TreeNode> queue = new LinkedList<>();

    // æ·±åº¦ä¼˜å…ˆéå†æ‰¾åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¿¡æ¯å¹¶è®°å½•åˆ°mapä¸­,æ ¹èŠ‚ç‚¹çš„parentä¸ºnull
    dfs(root, null);
    // ç›®æ ‡ç»“ç‚¹å…¥é˜Ÿåˆ—ä¸Setä¸­
    queue.add(targetNode);
    set.add(targetNode);
    // ä¸‹é¢æ˜¯å±‚åºéå†çš„é€»è¾‘BFS
    while (!queue.isEmpty() && K > 0) {
        // åˆ¤æ–­å½“å‰å±‚çš„ç»“ç‚¹æ•°
        int size = queue.size();
        // å±‚æ•°--
        K--;
        // å¼¹å‡ºè¿™ä¸€å±‚çš„å…¨éƒ¨ç»“ç‚¹,å‰é¢çš„å‡ å±‚ä¸åšæ•°æ®å¤„ç†
        while (size > 0) {
            TreeNode node = queue.poll();
            if (node.left != null && set.add(node.left) == true) queue.add(node.left);
            if (node.right != null && set.add(node.right) == true) queue.add(node.right);
            if (map.containsKey(node) && set.add(map.get(node)) == true) queue.add(map.get(node));
            size--;
        }
    }
    // ç°åœ¨åˆ°äº†ç¬¬Kå±‚è¿™ä¸€å±‚çš„æ•°æ®å°±æ˜¯ç­”æ¡ˆ
    while (!queue.isEmpty()) {
        resList.add(queue.poll().val);
    }

    return resList;
}

// æ‰¾åˆ°ç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¿¡æ¯å¹¶å­˜å…¥mapä¸­
public void dfs(TreeNode root, TreeNode parent) {
    if (parent != null) map.put(root, parent);
    if (root.left != null) dfs(root.left, root);
    if (root.right != null) dfs(root.right, root);
}
```

#### ğŸ’¯543.äºŒå‰æ ‘çš„ç›´å¾„ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/diameter-of-binary-tree)

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œä½ éœ€è¦è®¡ç®—å®ƒçš„**ç›´å¾„é•¿åº¦**ã€‚ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯**ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼**ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚

ç¤ºä¾‹ï¼šç»™å®šäºŒå‰æ ‘

          1
         / \
        2   3
       / \     
      4   5    

è¿”å› 3, å®ƒçš„é•¿åº¦æ˜¯è·¯å¾„ [4, 2, 1, 3] æˆ–è€… [5, 2, 1, 3]ã€‚æ³¨æ„ï¼šä¸¤ç»“ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦æ˜¯ä»¥å®ƒä»¬ä¹‹é—´è¾¹çš„æ•°ç›®è¡¨ç¤ºã€‚

##### 2. é¢˜è§£

###### (1) æ·±åº¦ä¼˜å…ˆæœç´¢

ä¸€æ¡è·¯å¾„çš„é•¿åº¦ä¸º**è¯¥è·¯å¾„ç»è¿‡çš„èŠ‚ç‚¹æ•°å‡ä¸€**ï¼Œæ‰€ä»¥æ±‚ç›´å¾„ï¼ˆå³æ±‚è·¯å¾„é•¿åº¦çš„æœ€å¤§å€¼ï¼‰ç­‰æ•ˆäºæ±‚è·¯å¾„ç»è¿‡èŠ‚ç‚¹æ•°çš„æœ€å¤§å€¼å‡ä¸€ã€‚è€Œä»»æ„ä¸€æ¡è·¯å¾„å‡å¯ä»¥è¢«çœ‹ä½œç”±æŸä¸ªèŠ‚ç‚¹ä¸ºèµ·ç‚¹ï¼Œä»å…¶**å·¦å„¿å­å’Œå³å„¿å­å‘ä¸‹éå†çš„è·¯å¾„æ‹¼æ¥**å¾—åˆ°ã€‚æ‰€ä»¥æ•´ä½“æ¶æ„æ˜¯**ååºéå†**ã€‚ä¹Ÿæ˜¯å…¸å‹çš„**æ ‘å½¢ dp** çš„æ–¹æ³•ã€‚

[è¿‡ç¨‹å›¾ç¤º](https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/shi-pin-jie-shi-di-gui-dai-ma-de-yun-xing-guo-chen/)

```java
int res = 0;
public int diameterOfBinaryTree(TreeNode root) {
    dfs(root);
    return res;
}

// è‡ªåº•å‘ä¸Šæš´åŠ›é€’å½’æ¨¡æ¿
public int dfs(TreeNode node) {
    // Base case
    if (node == null) return 0;
    // åˆ†åˆ«è·å–å·¦å³å­æ ‘çš„ç›´å¾„ä¿¡æ¯
    int leftDiameter = dfs(node.left);
    int rightDiameter = dfs(node.right);
    // è®¡ç®—L+R+1å¹¶æ›´æ–°ans
    res = Math.max(res, leftDiameter + rightDiameter + 1);
    // æ„é€ è‡ªå·±çš„ç›´å¾„å€¼å¹¶è¿”å›
    return Math.max(leftDiameter, rightDiameter) + 1;
}
```

---

#### 257.äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/binary-tree-paths)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚ç¤ºä¾‹è¾“å…¥ï¼š

```java
   1
 /   \
2     3
 \
  5
```

è¾“å‡º: ["1->2->5", "1->3"]ã€‚è§£é‡Š: æ‰€æœ‰æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ä¸º: 1->2->5, 1->3ã€‚

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

ç›´æ¥å°±æ˜¯**å‰åºé€’å½’**éå†çš„æ¨¡æ¿ï¼Œå½“é‡åˆ°**å­ç»“ç‚¹çš„æ—¶å€™è¿›è¡Œæ•°æ®å¤„ç†**ã€‚è¿™é‡Œä¸è¦ç”¨ StringBuilderï¼Œå®ƒä¼šè®°å½•çŠ¶æ€å¯¼è‡´ä¸æ­£ç¡®ã€‚

```java
private List<String> resList = new ArrayList<>();

public List<String> binaryTreePaths(TreeNode root) {
    if(root == null) return new ArrayList<>();
    dfs(root, "");
    return resList;
}

public void dfs(TreeNode root, String res) {
    // Base case
    if(root == null) return;
    // é‡åˆ°å¶å­èŠ‚ç‚¹å°±åŠ å…¥ç»“æœé›†å¹¶è¿”å›
    if(root.left == null && root.right == null) {
        res = res + root.val;
        resList.add(res);
        return;
        // éå¶å­èŠ‚ç‚¹å°±éœ€è¦é¢å¤–åŠ å…¥ç®­å¤´ç¬¦å·
    } else {
        res = res + root.val + "->";
    }
    // é€’å½’
    dfs(root.left, res);
    dfs(root.right, res);
}
```

#### 129.æ±‚æ ¹åˆ°å¶å­èŠ‚ç‚¹æ•°å­—ä¹‹å’Œã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œå®ƒçš„æ¯ä¸ªç»“ç‚¹éƒ½å­˜æ”¾ä¸€ä¸ª 0-9 çš„æ•°å­—ï¼Œæ¯æ¡ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªæ•°å­—ã€‚ä¾‹å¦‚ï¼Œä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 1->2->3 ä»£è¡¨æ•°å­— 123ã€‚è®¡ç®—ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹ç”Ÿæˆçš„æ‰€æœ‰æ•°å­—ä¹‹å’Œã€‚ç¤ºä¾‹ 1:

```java
è¾“å…¥: [1,2,3]
    1
   / \
  2   3
è¾“å‡º: 25
è§£é‡Š:
ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 1->2 ä»£è¡¨æ•°å­— 12.
ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 1->3 ä»£è¡¨æ•°å­— 13.
å› æ­¤ï¼Œæ•°å­—æ€»å’Œ = 12 + 13 = 25.
```

##### 2. é¢˜è§£

ç›´æ¥**å…ˆåºéå†**çš„æ¨¡æ¿å¥—ç”¨ä¸€ä¸‹å³å¯ï¼Œæ¯”è¾ƒå¥½ç†è§£ã€‚è‡ªå·±å†™çš„ä»£ç å¦‚ä¸‹ï¼š

```java
int res = 0;
public int sumNumbers(TreeNode root) {
    if(root == null) return 0;
    process(root, "");
    return res;
}

private void process(TreeNode root, String num) {
    if(root == null) return;
    num = num + root.val;
    // è¯´æ˜åˆ°äº†å­ç»“ç‚¹å°±è¿›è¡Œå¤„ç†
    if(root.left == null && root.right == null) {
        if(!"".equals(num)) {
            System.out.println(num);
            res = res + Integer.parseInt(num);
        }
        return;
    }
    process(root.left, num);
    process(root.right, num);
}
```

å¤§ä½¬çš„**ç®€çŸ­ä»£ç **ã€‚

```java
public int sumNumbers(TreeNode root) {
    return helper(root, 0);
}

public int helper(TreeNode root, int i){
    if (root == null) return 0;
    int temp = i * 10 + root.val;
    if (root.left == null && root.right == null) return temp;
    return helper(root.left, temp) + helper(root.right, temp);
}
```

#### 404.äºŒå‰æ ‘å·¦å­èŠ‚ç‚¹çš„å’Œã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/sum-of-left-leaves)

è®¡ç®—ç»™å®šäºŒå‰æ ‘çš„**æ‰€æœ‰å·¦å¶å­ä¹‹å’Œ**ã€‚ç¤ºä¾‹ï¼š

        3
       / \
      9  20
        /  \
       15   7

åœ¨è¿™ä¸ªäºŒå‰æ ‘ä¸­ï¼Œæœ‰ä¸¤ä¸ªå·¦å¶å­ï¼Œåˆ†åˆ«æ˜¯ 9 å’Œ 15ï¼Œæ‰€ä»¥è¿”å› 24ã€‚

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

æ•´ä½“**å…ˆåº**éå†ã€‚ç»´æŠ¤ä¸€ä¸ªå˜é‡ï¼Œç”¨äº**åˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦æ˜¯å·¦å­èŠ‚ç‚¹**ï¼Œå¦‚æœæ˜¯åˆ™åŠ ä¸Šï¼Œå¦åˆ™**ç»§ç»­é€’å½’**ã€‚

```java
private int sum;
public int sumOfLeftLeaves(TreeNode root) {
    process(root, false);
    return sum;
}
// é€’å½’æ•´ä½“å…ˆåºéå†çš„æ¶æ„
private void process(TreeNode root, boolean isLeft) {
    if(root == null) return;
    // å½“å‰èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ä¸”æ˜¯å·¦ç»“ç‚¹åˆ™ç›¸åŠ 
    if(root.left == null && root.right == null && isLeft) {
        sum = sum + root.val;
    }
    // é€’å½’å·¦å­æ ‘æ—¶é»˜è®¤ä¸ºtrueï¼Œå¦‚æœæ­¤æ—¶ä¸ºå­èŠ‚ç‚¹åˆ™åŠ èµ·æ¥
    process(root.left, true);
    process(root.right, false);
}
```

#### 687.æœ€é•¿åŒå€¼è·¯å¾„ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/longest-univalue-path)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾åˆ°**æœ€é•¿çš„è·¯å¾„**ï¼Œè¿™ä¸ªè·¯å¾„ä¸­çš„**æ¯ä¸ªèŠ‚ç‚¹å…·æœ‰ç›¸åŒå€¼**ã€‚ è¿™æ¡è·¯å¾„å¯ä»¥ç»è¿‡ä¹Ÿ**å¯ä»¥ä¸ç»è¿‡æ ¹èŠ‚ç‚¹**ã€‚æ³¨æ„ï¼šä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦ç”±å®ƒä»¬ä¹‹é—´çš„è¾¹æ•°è¡¨ç¤ºã€‚è¾“å…¥ï¼š

              5
             / \
            4   5
           / \   \
          1   1   5

è¾“å‡ºï¼š3ã€‚

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

æœ€é•¿åŒå€¼è·¯å¾„åˆ†ä¸º 2 ç§æƒ…å†µï¼š

1. ä»¥ root ä¸º**èµ·ç‚¹**ï¼Œç»è¿‡å·¦å­æ ‘æˆ–è€…å³å­æ ‘ï¼Œå¦‚å›¾ä¸­(2)ã€‚
2. ä¸æ˜¯ä»¥ root ä¸ºèµ·ç‚¹ï¼Œroot æ˜¯**ä¸­é—´ç‚¹**ï¼Œå¦‚å›¾ä¸­(1)ã€‚

<img src="assets/image-20200809002301843.png" alt="image-20200809002301843" style="zoom:60%;" />

```java
int res = 0;    // ç»“æœ
public int longestUnivaluePath(TreeNode root) {
    helper(root);
    return res;
}
// æœç´¢ä»¥rootä¸ºèµ·ç‚¹çš„æœ€é•¿åŒå€¼è·¯å¾„,è¦ä¹ˆç»è¿‡å·¦å­æ ‘ï¼Œè¦ä¹ˆç»è¿‡å³å­æ ‘
public int helper(TreeNode root) {
    if (root == null) return 0;
    // ä»¥rootä¸ºèµ·ç‚¹çš„æœ€é•¿åŒå€¼è·¯å¾„
    int maxLength = 0;
    int leftLength = helper(root.left);     // ä»¥root.leftä¸ºèµ·ç‚¹çš„æœ€é•¿åŒå€¼è·¯å¾„
    int rightLength = helper(root.right);   // ä»¥root.rightä¸ºèµ·ç‚¹çš„æœ€é•¿åŒå€¼è·¯å¾„
    // æƒ…å†µ2ï¼Œä¸éœ€è¦æ›´æ–°maxLengthï¼Œä½†è¦æ›´æ–°ç»“æœ
    if (root.left != null && root.right != null &&
        root.val == root.left.val && root.val == root.right.val) {
        res = Math.max(res, leftLength + rightLength + 2);
    }
    // ä»å·¦å³å­æ ‘ä¸­é€‰å–æœ€é•¿åŒå€¼è·¯å¾„
    if (root.left != null && root.val == root.left.val) {
        maxLength = leftLength + 1;
    }
    if (root.right != null && root.val == root.right.val) {
        maxLength = Math.max(maxLength, rightLength + 1);
    }
    // æ›´æ–°ç»“æœ
    res = Math.max(res, maxLength);
    return maxLength;
}
```

#### 563.äºŒå‰æ ‘çš„å¡åº¦ã€ç®€å•ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/binary-tree-tilt)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè®¡ç®—æ•´ä¸ªæ ‘çš„**å¡åº¦**ã€‚ä¸€ä¸ªæ ‘çš„èŠ‚ç‚¹çš„å¡åº¦å®šä¹‰ä¸ºï¼Œè¯¥èŠ‚ç‚¹**å·¦å­æ ‘çš„ç»“ç‚¹ä¹‹å’Œ**å’Œ**å³å­æ ‘ç»“ç‚¹ä¹‹å’Œ**çš„**å·®çš„ç»å¯¹å€¼**ã€‚ç©ºç»“ç‚¹çš„çš„å¡åº¦æ˜¯ 0ã€‚æ•´ä¸ªæ ‘çš„å¡åº¦å°±æ˜¯å…¶**æ‰€æœ‰èŠ‚ç‚¹**çš„**å¡åº¦ä¹‹å’Œ**ã€‚

```java
è¾“å…¥: 
         1
       /   \
      2     3
è¾“å‡º: 1
è§£é‡Š: 
ç»“ç‚¹çš„å¡åº¦ 2 : 0
ç»“ç‚¹çš„å¡åº¦ 3 : 0
ç»“ç‚¹çš„å¡åº¦ 1 : |2-3| = 1
æ ‘çš„å¡åº¦ : 0 + 0 + 1 = 1
```

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

å€ŸåŠ©**æš´åŠ›é€’å½’**çš„æ€æƒ³ï¼Œæ¯æ¬¡è¿­ä»£çš„**è¿”å›å€¼**æ˜¯ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ‘çš„æ•´æ£µæ ‘çš„**æ‰€æœ‰èŠ‚ç‚¹å€¼ä¹‹å’Œ**ã€‚ç„¶åé€’å½’çš„è¿‡ç¨‹ä¸­å°†æ¯ä¸ªèŠ‚ç‚¹çš„å¡åº¦è®¡ç®—å¹¶åŠ ä¸Šã€‚æš´åŠ›é€’å½’å¥½ç®€å•ã€‚æ•´ä¸ªæ¨¡æ¿æ˜¯**ååºéå†**æ¨¡æ¿ã€‚

```java
// æœ€åçš„ç­”æ¡ˆ
private int res = 0;

public int findTilt(TreeNode root) {
    process(root);
    return res;
}

// æš´åŠ›é€’å½’
private int process(TreeNode root) {
    // Base case
    if(root == null) return 0;
    // ä»å·¦å³å­æ ‘è·å–å…¶æ‰€æœ‰èŠ‚ç‚¹å€¼ä¹‹å’Œçš„ä¿¡æ¯
    int left = process(root.left);
    int right = process(root.right);
    // å½“æ—¶è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„å¡åº¦å€¼å¹¶æ›´æ–°res
    int poDu = Math.abs(left - right);
    res = res + poDu;
    // è¿”å›ä»¥è‡ªå·±ä¸ºæ ¹èŠ‚ç‚¹çš„æ•´æ£µæ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼ä¹‹å’Œ
    return left + right + root.val;
}
```

#### 1026.èŠ‚ç‚¹ä¸å…¶ç¥–å…ˆä¹‹é—´çš„æœ€å¤§å·®å€¼ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor)

ç»™å®š**äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root**ï¼Œæ‰¾å‡ºå­˜åœ¨äº**ä¸åŒèŠ‚ç‚¹ A å’Œ B ä¹‹é—´çš„æœ€å¤§å€¼ V**ï¼Œå…¶ä¸­ **V = |A.val - B.val|**ï¼Œ**ä¸” A æ˜¯ B çš„ç¥–å…ˆã€‚**ï¼ˆå¦‚æœ A çš„ä»»ä½•å­èŠ‚ç‚¹ä¹‹ä¸€ä¸º Bï¼Œæˆ–è€… A çš„ä»»ä½•å­èŠ‚ç‚¹æ˜¯ B çš„ç¥–å…ˆï¼Œé‚£ä¹ˆæˆ‘ä»¬è®¤ä¸º A æ˜¯ B çš„ç¥–å…ˆï¼‰ç¤ºä¾‹ï¼š

<img src="assets/image-20200517172143425.png" alt="image-20200517172143425" style="zoom:60%;" />

è¾“å…¥ï¼š[8,3,10,1,6,null,14,null,null,4,7,13]  è¾“å‡ºï¼š7
è§£é‡Šï¼š è¿™é‡Œæœ‰å¤§é‡çš„èŠ‚ç‚¹ä¸å…¶ç¥–å…ˆçš„å·®å€¼ï¼Œå…¶ä¸­ä¸€äº›å¦‚ä¸‹ï¼š

```java
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
```

åœ¨æ‰€æœ‰å¯èƒ½çš„å·®å€¼ä¸­ï¼Œæœ€å¤§å€¼ 7 ç”± **|8 - 1| = 7** å¾—å‡ºã€‚

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

å¯¹äºå½“å‰èŠ‚ç‚¹ nodeï¼šåœ¨å®ƒæ‰€åœ¨çš„è·¯å¾„ä¸Š(ä» root åˆ° node)çš„æœ€å¤§å·®å€¼ value å¿…å®šæ˜¯ MAX(abs(max_value-node.val), abs(min_value-node.val)) ã€‚å…¶ä¸­ max_value ä¸º**è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æœ€å¤§å€¼**ï¼Œmin_value ä¸ºè·¯å¾„ä¸Šçš„**èŠ‚ç‚¹æœ€å°å€¼**ï¼Œå› ä¸ºæœ€å¤§å·®å€¼çš„ç»å¯¹å€¼ value å¯èƒ½æ˜¯æœ€å¤§å€¼å‡å»å½“å‰èŠ‚ç‚¹å¾—åˆ°çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯æœ€å°å€¼å‡å»å½“å‰èŠ‚ç‚¹å¾—åˆ°çš„ï¼Œå¯ä»¥æƒ³è±¡æˆä¸€ä¸ª**æ•°è½´**ï¼Œä¸¤ç«¯åˆ†åˆ«ä¸º max_value å’Œ min_valueï¼Œæˆ‘ä»¬è¦æ±‚çš„ value å®é™…ä¸Šæ˜¯**èŠ‚ç‚¹åˆ°ä¸¤ç«¯çš„æœ€å¤§è·ç¦»**ã€‚

DFS çš„è¿‡ç¨‹ä¸­æ›´æ–° **max_value å’Œ min_value**ï¼ŒåŒæ—¶è®°å½•å½“å‰æœ€å¤§å€¼ res å³å¯ã€‚

```java
int res = 0;

public int maxAncestorDiff(TreeNode root) {
    dfs(root, root.val, root.val);
    return res;
}

public void dfs(TreeNode node, int maxValue, int minValue) {
    // Base case
    if (node == null) return;
    // æ›´æ–°ç»“æœ
    res = Math.max(res, Math.max(Math.abs(maxValue - node.val), Math.abs(minValue - node.val)));
    // æ›´æ–°æœ€å¤§å€¼
    if (node.val > maxValue) maxValue = node.val;
    // æ›´æ–°æœ€å°å€¼
    if (node.val < minValue) minValue = node.val;
    // é€’å½’
    dfs(node.left, maxValue, minValue);
    dfs(node.right, maxValue, minValue);
}
```

#### 988.ä»å¶ç»“ç‚¹å¼€å§‹çš„æœ€å°å­—ç¬¦ä¸²ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/smallest-string-starting-from-leaf)

ç»™å®šä¸€é¢—**æ ¹ç»“ç‚¹ä¸º root çš„äºŒå‰æ ‘**ï¼Œæ ‘ä¸­çš„æ¯ä¸€ä¸ªç»“ç‚¹éƒ½æœ‰ä¸€ä¸ªä» **0 åˆ° 25 çš„å€¼**ï¼Œåˆ†åˆ«ä»£è¡¨å­—æ¯ 'a' åˆ° 'z'ï¼šå€¼ 0 ä»£è¡¨ 'a'ï¼Œå€¼ 1 ä»£è¡¨ 'b'ï¼Œä¾æ­¤ç±»æ¨ã€‚æ‰¾å‡ºæŒ‰**å­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸²**ï¼Œè¯¥å­—ç¬¦ä¸²ä»è¿™æ£µæ ‘çš„ä¸€ä¸ª**å¶ç»“ç‚¹å¼€å§‹ï¼Œåˆ°æ ¹ç»“ç‚¹ç»“æŸ**ã€‚

ï¼ˆå°è´´å£«ï¼šå­—ç¬¦ä¸²ä¸­ä»»ä½•è¾ƒçŸ­çš„å‰ç¼€åœ¨å­—å…¸åºä¸Šéƒ½æ˜¯è¾ƒå°çš„ï¼šä¾‹å¦‚ï¼Œåœ¨å­—å…¸åºä¸Š "ab" æ¯” "aba" è¦å°ã€‚å¶ç»“ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­ç»“ç‚¹çš„ç»“ç‚¹ã€‚ï¼‰

**ç¤ºä¾‹ 1ï¼š**

<img src="assets/image-20200517185931314.png" alt="image-20200517185931314" style="zoom:57%;" />

```
è¾“å…¥ï¼š[25,1,3,1,3,0,2]  è¾“å‡ºï¼š"adz"
```

**ç¤ºä¾‹ 2ï¼š**

<img src="assets/image-20200517190044310.png" alt="image-20200517190044310" style="zoom:57%;" />

```
è¾“å…¥ï¼š[2,2,1,null,1,0,null,0]  è¾“å‡ºï¼š"abc"
```

##### 2. é¢˜è§£

###### (1) é€’å½’æ³•

ç›´æ¥ç”¨**å‰åºéå†**çš„æ–¹å¼éå†æ•´æ£µæ ‘ï¼ŒåŒæ—¶è®°å½•éå†çš„è·¯å¾„ï¼Œå¦‚æœéå†åˆ°å½“å‰èŠ‚ç‚¹æ˜¯**å¶å­èŠ‚ç‚¹**ï¼Œåˆ™è¿›è¡Œ**å­—å…¸åºçš„å¯¹æ¯”ï¼Œå¦‚æœå°å°±æ›´æ–°**ã€‚

```java
private String resStr = "";

public String smallestFromLeaf(TreeNode root) {
    if (root == null) {
        return "";
    }
    dfs(root, "");
    return resStr;
}

private void dfs(TreeNode root, String path) {
    if (root == null) return;
    // æ„é€ å­—ç¬¦ä¸²
    path = (char) ('a' + root.val) + path;
    // å½“å‰çš„ç»“ç‚¹ä¸ºå¶å­ç»“ç‚¹ï¼Œæ­¤æ—¶åˆ©ç”¨å­—ç¬¦ä¸²è¿›è¡Œå¯¹æ¯”
    if (root.left == null && root.right == null) {
        // è‹¥æ‰€ç”Ÿæˆå­—ç¬¦ä¸²æ¯”å½“å‰æœ€å°å­—ç¬¦ä¸²å°ï¼Œåˆ™æ›´æ–°ä¿ç•™
        if ("".equals(resStr) || path.compareTo(resStr) < 0) resStr = path;
        return; 
    }
    // é€’å½’
    dfs(root.left, path);
    dfs(root.right, path);
}
```



### Trieæ ‘

<img src="assets/1563524946852.png" alt="1563524946852" style="zoom:70%;" />

Trieï¼Œåˆç§°**å‰ç¼€æ ‘æˆ–å­—å…¸æ ‘**ï¼Œç”¨äºåˆ¤æ–­**å­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨æˆ–è€…æ˜¯å¦å…·æœ‰æŸç§å­—ç¬¦ä¸²å‰ç¼€**ã€‚

#### 208.å®ç°ä¸€ä¸ªTrieã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

å®ç°ä¸€ä¸ª Trie (å‰ç¼€æ ‘)ï¼ŒåŒ…å« insert, search, å’Œ startsWith è¿™ä¸‰ä¸ªæ“ä½œã€‚ä½ å¯ä»¥å‡è®¾æ‰€æœ‰çš„è¾“å…¥éƒ½æ˜¯ç”±å°å†™å­—æ¯ a-z æ„æˆçš„ã€‚

```java
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // è¿”å› true
trie.search("app");     // è¿”å› false
trie.startsWith("app"); // è¿”å› true
trie.insert("app");   
trie.search("app");     // è¿”å› true
```

##### 2. é¢˜è§£

```java
class Trie {

    private class Node {
        Node[] childs = new Node[26];
        boolean isLeaf;
    }

    private Node root = new Node();

    public Trie() {
    }

    public void insert(String word) {
        insert(word, root);
    }

    private void insert(String word, Node node) {
        if (node == null) return;
        if (word.length() == 0) {
            node.isLeaf = true;
            return;
        }
        int index = indexForChar(word.charAt(0));
        if (node.childs[index] == null) {
            node.childs[index] = new Node();
        }
        insert(word.substring(1), node.childs[index]);
    }

    public boolean search(String word) {
        return search(word, root);
    }

    private boolean search(String word, Node node) {
        if (node == null) return false;
        if (word.length() == 0) return node.isLeaf;
        int index = indexForChar(word.charAt(0));
        return search(word.substring(1), node.childs[index]);
    }

    public boolean startsWith(String prefix) {
        return startWith(prefix, root);
    }

    private boolean startWith(String prefix, Node node) {
        if (node == null) return false;
        if (prefix.length() == 0) return true;
        int index = indexForChar(prefix.charAt(0));
        return startWith(prefix.substring(1), node.childs[index]);
    }

    private int indexForChar(char c) {
        return c - 'a';
    }
}
```

#### 677.é”®å€¼æ˜ å°„ã€ä¸­ç­‰ã€‘

##### [1. é¢˜ç›®](https://leetcode-cn.com/problems/map-sum-pairs/)

å®ç°ä¸€ä¸ª **MapSum ç±»**é‡Œçš„ä¸¤ä¸ªæ–¹æ³•ï¼Œinsert å’Œ sumã€‚å¯¹äºæ–¹æ³• insertï¼Œä½ å°†å¾—åˆ°ä¸€å¯¹ï¼ˆå­—ç¬¦ä¸²ï¼Œæ•´æ•°ï¼‰çš„é”®å€¼å¯¹ã€‚å­—ç¬¦ä¸²è¡¨ç¤ºé”®ï¼Œæ•´æ•°è¡¨ç¤ºå€¼ã€‚å¦‚æœé”®å·²ç»å­˜åœ¨ï¼Œé‚£ä¹ˆåŸæ¥çš„é”®å€¼å¯¹å°†è¢«æ›¿ä»£æˆæ–°çš„é”®å€¼å¯¹ã€‚å¯¹äºæ–¹æ³• sumï¼Œä½ å°†å¾—åˆ°ä¸€ä¸ª**è¡¨ç¤ºå‰ç¼€çš„å­—ç¬¦ä¸²**ï¼Œä½ éœ€è¦è¿”å›æ‰€æœ‰ä»¥è¯¥å‰ç¼€å¼€å¤´çš„é”®çš„å€¼çš„æ€»å’Œã€‚

```java
è¾“å…¥: insert("apple", 3), è¾“å‡º: Null
è¾“å…¥: sum("ap"), è¾“å‡º: 3
è¾“å…¥: insert("app", 2), è¾“å‡º: Null
è¾“å…¥: sum("ap"), è¾“å‡º: 5
```

##### 2. é¢˜è§£

```java
class MapSum {

    private class Node {
        Node[] child = new Node[26];
        int value;
    }

    private Node root = new Node();

    public MapSum() {

    }

    public void insert(String key, int val) {
        insert(key, root, val);
    }

    private void insert(String key, Node node, int val) {
        if (node == null) return;
        if (key.length() == 0) {
            node.value = val;
            return;
        }
        int index = indexForChar(key.charAt(0));
        if (node.child[index] == null) {
            node.child[index] = new Node();
        }
        insert(key.substring(1), node.child[index], val);
    }

    public int sum(String prefix) {
        return sum(prefix, root);
    }

    private int sum(String prefix, Node node) {
        if (node == null) return 0;
        if (prefix.length() != 0) {
            int index = indexForChar(prefix.charAt(0));
            return sum(prefix.substring(1), node.child[index]);
        }
        int sum = node.value;
        for (Node child : node.child) {
            sum += sum(prefix, child);
        }
        return sum;
    }

    private int indexForChar(char c) {
        return c - 'a';
    }
}
```





